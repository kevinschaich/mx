<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MX Dialpad Configuration</title>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1800px;
      margin: 0 auto;
    }
    
    h1 {
      color: white;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }
    
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    @media (min-width: 1200px) {
      .grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }
    
    @media (max-width: 768px) {
      .grid {
        grid-template-columns: 1fr;
      }
      
      h1 {
        font-size: 1.8em;
      }
    }
    
    .card {
      background: white;
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    
    .card h2 {
      margin-bottom: 16px;
      color: #333;
      font-size: 1.5em;
      border-bottom: 2px solid #667eea;
      padding-bottom: 8px;
    }
    
    .status {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff4d4f;
      animation: pulse 2s infinite;
    }
    
    .status-dot.connected {
      background: #52c41a;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    button.primary {
      background: #667eea;
      color: white;
    }
    
    button.danger {
      background: #ff4d4f;
      color: white;
    }
    
    button.success {
      background: #52c41a;
      color: white;
    }
    
    .mapping-item {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
      align-items: center;
    }
    
    .mapping-item input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #d9d9d9;
      border-radius: 6px;
      font-size: 14px;
    }
    
    .mapping-item input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .mapping-item button {
      padding: 8px 12px;
    }
    
    .add-mapping {
      margin-top: 16px;
    }
    
    .log {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 16px;
      border-radius: 8px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 13px;
      max-height: 500px;
      overflow-y: auto;
      line-height: 1.6;
    }
    
    .log-entry {
      margin-bottom: 12px;
      padding: 8px;
      background: #2d2d2d;
      border-radius: 4px;
      border-left: 3px solid #667eea;
    }
    
    .log-entry.button {
      border-left-color: #52c41a;
    }
    
    .log-entry.scroll {
      border-left-color: #faad14;
    }
    
    .log-entry.known {
      background: #1f3a1f;
      border-left-width: 4px;
    }
    
    .timestamp {
      color: #888;
      font-size: 11px;
    }
    
    .event-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      margin-right: 8px;
    }
    
    .event-badge.button { background: #52c41a; color: white; }
    .event-badge.scroll { background: #faad14; color: white; }
    .event-badge.value { background: #1890ff; color: white; }
    
    .log-actions {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .log-actions button {
      padding: 4px 10px;
      font-size: 11px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .log-actions button:hover {
      background: #5568d3;
    }
    
    .log-actions input {
      padding: 4px 8px;
      font-size: 12px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #1e1e1e;
      color: #d4d4d4;
      width: 150px;
    }
    
    .log-actions input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #52c41a;
      color: white;
      padding: 16px 24px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      animation: slideIn 0.3s ease-out;
      font-weight: 600;
    }
    
    .toast.warning {
      background: #faad14;
    }
    
    .toast.error {
      background: #ff4d4f;
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    .clear-log {
      margin-top: 12px;
    }
    
    .full-width {
      grid-column: 1 / -1;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéõÔ∏è MX Dialpad Configuration</h1>
    
    <div class="grid">
      <!-- Status Card -->
      <div class="card">
        <h2>Device Status</h2>
        <div class="status">
          <div class="status-dot" id="statusDot"></div>
          <span id="statusText">Disconnected</span>
        </div>
        <p>Reports received: <strong id="reportCount">0</strong></p>
      </div>
      
      <!-- Jog Wheel Visualization -->
      <div class="card">
        <h2>Jog Wheel Position</h2>
        <div style="text-align: center;">
          <svg width="200" height="200" style="margin: 0 auto; display: block;">
            <circle cx="100" cy="100" r="80" fill="none" stroke="#e0e0e0" stroke-width="10"/>
            <circle id="jogProgress" cx="100" cy="100" r="80" fill="none" stroke="#667eea" stroke-width="10"
                    stroke-dasharray="502.65" stroke-dashoffset="502.65"
                    transform="rotate(-90 100 100)" stroke-linecap="round"/>
            <text x="100" y="100" text-anchor="middle" dy=".3em" font-size="24" font-weight="bold" fill="#333" id="jogPosition">0</text>
          </svg>
          <div style="margin-top: 12px; display: flex; justify-content: space-around;">
            <div>
              <div style="font-size: 11px; color: #999;">Total Scrolls</div>
              <div style="font-size: 18px; font-weight: bold;" id="jogScrolls">0</div>
            </div>
            <div>
              <div style="font-size: 11px; color: #999;">Last Speed</div>
              <div style="font-size: 18px; font-weight: bold;" id="jogSpeed">‚Äî</div>
            </div>
            <div>
              <div style="font-size: 11px; color: #999;">Highest Speed</div>
              <div style="font-size: 18px; font-weight: bold; color: #ff4d4f;" id="jogHighestSpeed">0</div>
            </div>
            <div>
              <div style="font-size: 11px; color: #999;">Direction</div>
              <div style="font-size: 18px; font-weight: bold;" id="jogDirection">‚Äî</div>
            </div>
          </div>
          <button onclick="resetJogPosition()" style="margin-top: 12px; padding: 6px 16px; font-size: 12px; background: #faad14; color: white; border: none; border-radius: 4px; cursor: pointer;">
            Reset Position
          </button>
        </div>
      </div>
      
      <!-- Scroll Wheel Visualization -->
      <div class="card">
        <h2>Scroll Wheel Position</h2>
        <div style="text-align: center;">
          <div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
            <div style="position: relative; width: 40px; height: 300px; background: #e0e0e0; border-radius: 20px; overflow: hidden;">
              <div id="scrollProgress" style="position: absolute; bottom: 0; width: 100%; background: linear-gradient(to top, #52c41a, #91d5ff); transition: height 0.1s ease-out; height: 50%;"></div>
              <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 2px; height: 100%; background: rgba(0,0,0,0.2);"></div>
            </div>
            <div style="text-align: left;">
              <div style="margin-bottom: 12px;">
                <div style="font-size: 32px; font-weight: bold;" id="scrollPosition">0</div>
                <div style="font-size: 11px; color: #999;">Position</div>
              </div>
              <div style="margin-bottom: 12px;">
                <div style="font-size: 18px; font-weight: bold;" id="scrollScrolls">0</div>
                <div style="font-size: 11px; color: #999;">Total Scrolls</div>
              </div>
              <div style="margin-bottom: 12px;">
                <div style="font-size: 18px; font-weight: bold;" id="scrollSpeed">‚Äî</div>
                <div style="font-size: 11px; color: #999;">Last Speed</div>
              </div>
              <div style="margin-bottom: 12px;">
                <div style="font-size: 18px; font-weight: bold; color: #ff4d4f;" id="scrollHighestSpeed">0</div>
                <div style="font-size: 11px; color: #999;">Highest Speed</div>
              </div>
              <div style="margin-bottom: 12px;">
                <div style="font-size: 18px; font-weight: bold;" id="scrollDirection">‚Äî</div>
                <div style="font-size: 11px; color: #999;">Direction</div>
              </div>
            </div>
          </div>
          <button onclick="resetScrollPosition()" style="margin-top: 12px; padding: 6px 16px; font-size: 12px; background: #faad14; color: white; border: none; border-radius: 4px; cursor: pointer;">
            Reset Position
          </button>
        </div>
      </div>
      
      <!-- Buttons Mapping -->
      <div class="card">
        <h2>Button Mappings</h2>
        <div id="buttonMappings"></div>
        <div class="add-mapping">
          <input type="number" id="newButtonByte" placeholder="Byte" style="width: 70px;">
          <input type="number" id="newButtonBit" placeholder="Bit (optional)" style="width: 100px;">
          <input type="text" id="newButtonName" placeholder="Button name">
          <button class="primary" onclick="addButtonMapping()">Add</button>
        </div>
      </div>
      
      <!-- Scroll Wheel Mapping -->
      <div class="card">
        <h2>Scroll Wheel Mappings</h2>
        <div id="scrollMappings"></div>
        <div class="add-mapping">
          <input type="number" id="newScrollByte" placeholder="Byte index" style="width: 100px;">
          <input type="text" id="newScrollName" placeholder="Wheel name">
          <button class="primary" onclick="addScrollMapping()">Add</button>
        </div>
      </div>
      
      <!-- Velocity & Input Visualization -->
      <div class="card">
        <h2>Velocity & Input</h2>
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500;">Easing Function:</label>
          <div id="easingPicker" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 8px;">
            <!-- Easing function previews will be inserted here -->
          </div>
        </div>
        <div style="text-align: center; background: #f9f9f9; padding: 16px; border-radius: 8px;">
          <canvas id="curveCanvas" width="300" height="200" style="border: 1px solid #ddd; border-radius: 4px; background: white;"></canvas>
          <div style="margin-top: 12px; display: flex; justify-content: space-around; font-size: 12px;">
            <div>
              <div style="color: #999;">Raw Input</div>
              <div style="font-size: 20px; font-weight: bold; color: #faad14;" id="currentInput">0</div>
            </div>
            <div>
              <div style="color: #999;">Velocity</div>
              <div style="font-size: 20px; font-weight: bold; color: #667eea;" id="currentVelocity">0</div>
            </div>
            <div>
              <div style="color: #999;">Multiplier</div>
              <div style="font-size: 20px; font-weight: bold; color: #52c41a;" id="effectiveness">0.0x</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Input vs Velocity Timeline -->
      <div class="card">
        <h2>Input vs Velocity Timeline</h2>
        <div style="text-align: center; background: #f9f9f9; padding: 16px; border-radius: 8px;">
          <canvas id="timelineCanvas" width="300" height="200" style="border: 1px solid #ddd; border-radius: 4px; background: white;"></canvas>
          <div style="margin-top: 12px; display: flex; justify-content: space-around; font-size: 11px;">
            <div style="display: flex; align-items: center; gap: 4px;">
              <div style="width: 12px; height: 12px; background: #faad14; border-radius: 2px;"></div>
              <span>Raw Input</span>
            </div>
            <div style="display: flex; align-items: center; gap: 4px;">
              <div style="width: 12px; height: 12px; background: #667eea; border-radius: 2px;"></div>
              <span>Velocity (with friction)</span>
            </div>
          </div>
          <div style="margin-top: 8px; font-size: 11px; color: #999;">Last 3 seconds</div>
        </div>
      </div>
      
      <!-- Actions -->
      <div class="card">
        <h2>Actions</h2>
        <p style="font-size: 13px; color: #666; margin-bottom: 12px;">
          üí° Quick-add from logs auto-saves! Use this button if you manually edit mappings above.
        </p>
        <button class="success" onclick="saveConfig()">üíæ Save Configuration</button>
        <button class="danger" onclick="clearConfig()">üóëÔ∏è Clear All Mappings</button>
      </div>
      
      <!-- Live Log -->
      <div class="card full-width">
        <h2>Live Event Log</h2>
        <div class="log" id="log"></div>
        <button class="primary clear-log" onclick="clearLog()">Clear Log</button>
      </div>
    </div>
  </div>

  <script>
    const socket = io();
    let config = { buttons: {}, scrollWheels: {} };
    let logEntries = [];
    const MAX_LOG_ENTRIES = 100;
    let jogWheelData = {
      position: 0,
      totalScrolls: 0,
      lastDirection: null,
      highestSpeed: 0,
      currentSeriesHighest: 0,
      debounceTimer: null,
      velocity: 0,
      lastInputTime: 0,
      animationFrame: null
    };
    let scrollWheelData = {
      position: 0,
      totalScrolls: 0,
      lastDirection: null,
      highestSpeed: 0,
      currentSeriesHighest: 0,
      debounceTimer: null,
      velocity: 0,
      lastInputTime: 0,
      animationFrame: null
    };
    
    // Timeline data tracking
    const TIMELINE_DURATION = 3000; // 3 seconds in ms
    let timelineData = {
      inputs: [], // [{time, value}]
      velocities: [], // [{time, value}]
      lastUpdateTime: Date.now()
    };
    
    // Input display tracking (for bar chart)
    let inputDisplayData = {
      value: 0,
      lastInputTime: 0,
      holdDuration: 200 // Hold input display for 200ms after last input
    };
    
    // Physics constants
    const FRICTION = 0.92; // Velocity multiplier per frame (closer to 1 = less friction)
    const VELOCITY_THRESHOLD = 0.1; // Stop animating below this velocity
    const TARGET_MULTIPLIER = 2.5; // How much to scale input speed for target velocity
    const ACCELERATION_RATE = 0.15; // How quickly to approach target velocity
    
    // Current easing function
    let currentEasingFunction = 'easeOutQuad';
    
    // Easing function metadata
    const easingMetadata = [
      { id: 'linear', name: 'Linear' },
      { id: 'easeInQuad', name: 'Ease In' },
      { id: 'easeOutQuad', name: 'Ease Out' },
      { id: 'easeInOutQuad', name: 'In-Out' },
      { id: 'easeInCubic', name: 'Cubic In' },
      { id: 'easeOutCubic', name: 'Cubic Out' },
      { id: 'easeInOutCubic', name: 'Cubic In-Out' },
      { id: 'easeInExpo', name: 'Expo In' },
      { id: 'easeOutExpo', name: 'Expo Out' },
      { id: 'easeInOutExpo', name: 'Expo In-Out' }
    ];
    
    // Easing functions for acceleration curves
    const easingFunctions = {
      linear: (t) => t,
      easeInQuad: (t) => t * t,
      easeOutQuad: (t) => t * (2 - t),
      easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
      easeInCubic: (t) => t * t * t,
      easeOutCubic: (t) => (--t) * t * t + 1,
      easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
      easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
      easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
      easeInOutExpo: (t) => {
        if (t === 0 || t === 1) return t;
        return t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
      }
    };
    
    // Socket events
    socket.on('connect', () => {
      console.log('Connected to server');
    });
    
    socket.on('config', (data) => {
      config = data;
      renderMappings();
    });
    
    socket.on('status', (data) => {
      updateStatus(data);
    });
    
    socket.on('report', (report) => {
      updateLog(report);
    });
    
    // Update status
    function updateStatus(status) {
      const dot = document.getElementById('statusDot');
      const text = document.getElementById('statusText');
      const count = document.getElementById('reportCount');
      
      if (status.connected) {
        dot.classList.add('connected');
        text.textContent = 'Connected';
      } else {
        dot.classList.remove('connected');
        text.textContent = 'Disconnected';
      }
      
      count.textContent = status.reportCount;
    }
    
    // Render mappings
    function renderMappings() {
      const buttonContainer = document.getElementById('buttonMappings');
      const scrollContainer = document.getElementById('scrollMappings');
      
      buttonContainer.innerHTML = '';
      scrollContainer.innerHTML = '';
      
      Object.entries(config.buttons || {}).forEach(([key, name]) => {
        const displayKey = key.includes(':') ? `Byte ${key.split(':')[0]} bit ${key.split(':')[1]}` : `Byte ${key}`;
        buttonContainer.innerHTML += `
          <div class="mapping-item">
            <input type="text" value="${displayKey}" disabled style="width: 150px;">
            <input type="text" value="${name}" onchange="updateButtonMapping('${key}', this.value)">
            <button class="danger" onclick="removeButtonMapping('${key}')">‚úï</button>
          </div>
        `;
      });
      
      Object.entries(config.scrollWheels || {}).forEach(([byte, name]) => {
        scrollContainer.innerHTML += `
          <div class="mapping-item">
            <input type="text" value="Byte ${byte}" disabled style="width: 100px;">
            <input type="text" value="${name}" onchange="updateScrollMapping(${byte}, this.value)">
            <button class="danger" onclick="removeScrollMapping(${byte})">‚úï</button>
          </div>
        `;
      });
    }
    
    // Add mappings
    function addButtonMapping() {
      const byte = document.getElementById('newButtonByte').value;
      const bit = document.getElementById('newButtonBit').value;
      const name = document.getElementById('newButtonName').value;
      
      if (byte && name) {
        const key = bit ? `${byte}:${bit}` : byte;
        config.buttons[key] = name;
        document.getElementById('newButtonByte').value = '';
        document.getElementById('newButtonBit').value = '';
        document.getElementById('newButtonName').value = '';
        renderMappings();
      }
    }
    
    function addScrollMapping() {
      const byte = document.getElementById('newScrollByte').value;
      const name = document.getElementById('newScrollName').value;
      
      if (byte && name) {
        config.scrollWheels[byte] = name;
        document.getElementById('newScrollByte').value = '';
        document.getElementById('newScrollName').value = '';
        renderMappings();
      }
    }
    
    // Update mappings
    function updateButtonMapping(key, name) {
      config.buttons[key] = name;
    }
    
    function updateScrollMapping(byte, name) {
      config.scrollWheels[byte] = name;
    }
    
    // Remove mappings
    function removeButtonMapping(key) {
      delete config.buttons[key];
      renderMappings();
    }
    
    function removeScrollMapping(byte) {
      delete config.scrollWheels[byte];
      renderMappings();
    }
    
    // Save config
    async function saveConfig() {
      const response = await fetch('/api/config', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
      });
      
      if (response.ok) {
        showToast('‚úÖ Configuration saved successfully!');
      } else {
        showToast('‚ùå Failed to save configuration', 'error');
      }
    }
    
    // Clear config
    function clearConfig() {
      if (confirm('‚ö†Ô∏è Are you sure you want to clear all mappings?\n\nThis will remove all button and scroll wheel mappings.\n\nDon\'t forget to save after clearing!')) {
        config = { buttons: {}, scrollWheels: {} };
        renderMappings();
        showToast('üóëÔ∏è All mappings cleared (save to persist)');
      }
    }
    
    // Draw timeline chart showing input vs velocity over time
    function drawTimeline() {
      const canvas = document.getElementById('timelineCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 30;
      const centerY = height / 2;
      const now = Date.now();
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw center horizontal axis
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, centerY);
      ctx.lineTo(width - padding, centerY);
      ctx.stroke();
      
      // Draw vertical axis
      ctx.strokeStyle = '#ccc';
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.stroke();
      
      // Draw time grid lines (every 500ms)
      ctx.strokeStyle = '#f0f0f0';
      ctx.lineWidth = 1;
      for (let i = 1; i <= 6; i++) {
        const x = padding + (i * (width - 2 * padding) / 6);
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      }
      
      // Draw axis labels
      ctx.fillStyle = '#666';
      ctx.font = '10px sans-serif';
      ctx.fillText('-3s', padding - 5, height - padding + 15);
      ctx.fillText('now', width - padding - 10, height - padding + 15);
      
      // Clean old data
      const cutoffTime = now - TIMELINE_DURATION;
      timelineData.inputs = timelineData.inputs.filter(d => d.time > cutoffTime);
      timelineData.velocities = timelineData.velocities.filter(d => d.time > cutoffTime);
      
      // Helper to convert time to x position
      const timeToX = (time) => {
        const age = now - time;
        const ratio = 1 - (age / TIMELINE_DURATION);
        return padding + ratio * (width - 2 * padding);
      };
      
      // Helper to convert value to y position
      const valueToY = (value) => {
        const maxValue = 100;
        const ratio = Math.max(-1, Math.min(1, value / maxValue));
        return centerY - ratio * (centerY - padding);
      };
      
      // Draw velocity line (smooth)
      if (timelineData.velocities.length > 1) {
        ctx.strokeStyle = '#667eea';
        ctx.lineWidth = 2;
        ctx.beginPath();
        timelineData.velocities.forEach((d, i) => {
          const x = timeToX(d.time);
          const y = valueToY(d.value);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();
      }
      
      // Draw input spikes (as bars)
      ctx.fillStyle = '#faad14';
      timelineData.inputs.forEach(d => {
        const x = timeToX(d.time);
        const y = valueToY(d.value);
        const barWidth = 3;
        
        // Draw bar from center to value
        ctx.fillRect(x - barWidth/2, Math.min(centerY, y), barWidth, Math.abs(centerY - y));
      });
    }
    
    // Update timeline with current data
    function updateTimeline() {
      const now = Date.now();
      
      // Add current velocities (for smooth line)
      if (jogWheelData.velocity !== 0 || scrollWheelData.velocity !== 0) {
        // Use whichever has velocity (or combine them)
        const velocity = Math.abs(jogWheelData.velocity) > Math.abs(scrollWheelData.velocity) 
          ? jogWheelData.velocity 
          : scrollWheelData.velocity;
        timelineData.velocities.push({ time: now, value: velocity });
      } else if (timelineData.velocities.length > 0) {
        // Add zero point when velocity stops
        const lastVelocity = timelineData.velocities[timelineData.velocities.length - 1];
        if (lastVelocity.value !== 0) {
          timelineData.velocities.push({ time: now, value: 0 });
        }
      }
      
      // Redraw
      drawTimeline();
    }
    
    // Record input event on timeline
    function recordInputEvent(velocity, inputAmount) {
      const now = Date.now();
      const signedInput = velocity >= 0 ? inputAmount : -inputAmount;
      timelineData.inputs.push({ time: now, value: signedInput });
    }
    
    // Draw simple velocity vs input bars
    function drawAccelerationCurve() {
      const canvas = document.getElementById('curveCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 40;
      const centerY = height / 2;
      const barWidth = 50;
      const spacing = 100;
      const now = Date.now();
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw center line
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, centerY);
      ctx.lineTo(width - padding, centerY);
      ctx.stroke();
      
      // Draw scale marks
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 1;
      ctx.font = '10px sans-serif';
      ctx.fillStyle = '#999';
      for (let i = -100; i <= 100; i += 50) {
        if (i === 0) continue;
        const y = centerY - (i / 100) * (centerY - padding);
        ctx.beginPath();
        ctx.moveTo(padding - 5, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
        ctx.fillText(i > 0 ? `+${i}` : i.toString(), 5, y + 3);
      }
      
      // Check if we should still show the input or fade it
      const timeSinceInput = now - inputDisplayData.lastInputTime;
      let inputValue = 0;
      
      if (timeSinceInput < inputDisplayData.holdDuration) {
        // Show full input value during hold period
        inputValue = inputDisplayData.value;
      } else {
        // Input has expired
        inputValue = 0;
      }
      
      // Get velocity with smooth interpolation
      if (!window.smoothDisplayVelocity) window.smoothDisplayVelocity = 0;
      const targetVelocity = window.currentDisplayVelocity || 0;
      
      // Smooth interpolation for velocity only
      const smoothFactor = 0.2;
      window.smoothDisplayVelocity += (targetVelocity - window.smoothDisplayVelocity) * smoothFactor;
      
      const velocityValue = window.smoothDisplayVelocity;
      
      // Update multiplier text if we have values
      if (Math.abs(inputValue) > 1 && Math.abs(velocityValue) > 1) {
        const multiplier = Math.abs(velocityValue) / Math.max(Math.abs(inputValue), 1);
        document.getElementById('effectiveness').textContent = multiplier.toFixed(1) + 'x';
      } else if (Math.abs(velocityValue) < 1) {
        document.getElementById('effectiveness').textContent = '‚Äî';
      }
      
      // Helper to draw a bar
      const drawBar = (x, value, color, label) => {
        const maxValue = 100;
        const clampedValue = Math.max(-maxValue, Math.min(maxValue, value));
        const barHeight = (Math.abs(clampedValue) / maxValue) * (centerY - padding - 10);
        const barY = clampedValue >= 0 ? centerY - barHeight : centerY;
        
        // Draw bar
        ctx.fillStyle = color;
        ctx.fillRect(x - barWidth/2, barY, barWidth, Math.abs(barHeight));
        
        // Draw outline
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.strokeRect(x - barWidth/2, barY, barWidth, Math.abs(barHeight));
        
        // Draw label
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(label, x, height - padding + 20);
        
        // Draw value
        ctx.fillStyle = color;
        ctx.font = 'bold 14px sans-serif';
        const valueY = clampedValue >= 0 ? barY - 5 : barY + Math.abs(barHeight) + 15;
        ctx.fillText(Math.round(value).toString(), x, valueY);
      };
      
      // Draw input bar (left)
      const inputX = width / 2 - spacing / 2;
      drawBar(inputX, inputValue, '#faad14', 'Input');
      
      // Draw velocity bar (right)
      const velocityX = width / 2 + spacing / 2;
      drawBar(velocityX, velocityValue, '#667eea', 'Velocity');
      
      // Draw arrow between them if there's a difference
      if (Math.abs(inputValue) > 1 || Math.abs(velocityValue) > 1) {
        const arrowY = centerY + (centerY - padding) / 2 + 20;
        ctx.strokeStyle = '#52c41a';
        ctx.fillStyle = '#52c41a';
        ctx.lineWidth = 2;
        
        // Arrow line
        ctx.beginPath();
        ctx.moveTo(inputX + barWidth/2 + 5, arrowY);
        ctx.lineTo(velocityX - barWidth/2 - 10, arrowY);
        ctx.stroke();
        
        // Arrow head
        ctx.beginPath();
        ctx.moveTo(velocityX - barWidth/2 - 10, arrowY);
        ctx.lineTo(velocityX - barWidth/2 - 18, arrowY - 4);
        ctx.lineTo(velocityX - barWidth/2 - 18, arrowY + 4);
        ctx.closePath();
        ctx.fill();
      }
      
      // Continue animation if velocity is changing or input is still being held
      if (Math.abs(window.smoothDisplayVelocity - targetVelocity) > 0.5 || timeSinceInput < inputDisplayData.holdDuration) {
        requestAnimationFrame(drawAccelerationCurve);
      }
    }
    
    // Update curve visualization with current values
    function updateCurveVisualization(inputSpeed, velocity) {
      // Store input value with timestamp for display hold
      inputDisplayData.value = inputSpeed;
      inputDisplayData.lastInputTime = Date.now();
      
      // Store velocity for smooth rendering
      window.currentDisplayVelocity = velocity;
      
      // Update text displays (show absolute values)
      document.getElementById('currentInput').textContent = Math.round(Math.abs(inputSpeed));
      document.getElementById('currentVelocity').textContent = Math.round(Math.abs(velocity));
      
      // Calculate and display multiplier
      if (Math.abs(inputSpeed) < 1 && Math.abs(velocity) < 1) {
        document.getElementById('effectiveness').textContent = '‚Äî';
      } else {
        const multiplier = Math.abs(velocity) / Math.max(Math.abs(inputSpeed), 1);
        document.getElementById('effectiveness').textContent = multiplier.toFixed(1) + 'x';
      }
      
      // Trigger smooth animation
      drawAccelerationCurve();
    }
    
    // Initialize curve visualization on load
    window.addEventListener('load', () => {
      renderEasingPicker();
      drawAccelerationCurve();
      drawTimeline();
      // Start timeline update loop
      setInterval(updateTimeline, 50); // Update 20 times per second
    });
    
    // Render easing function picker with visual previews
    function renderEasingPicker() {
      const container = document.getElementById('easingPicker');
      container.innerHTML = '';
      
      easingMetadata.forEach(easing => {
        const button = document.createElement('div');
        button.style.cssText = `
          cursor: pointer;
          padding: 8px;
          border: 2px solid ${easing.id === currentEasingFunction ? '#667eea' : '#ddd'};
          border-radius: 8px;
          background: ${easing.id === currentEasingFunction ? '#f0f2ff' : 'white'};
          transition: all 0.2s;
          text-align: center;
        `;
        
        // Create mini canvas for curve preview
        const canvas = document.createElement('canvas');
        canvas.width = 60;
        canvas.height = 40;
        canvas.style.cssText = 'display: block; margin: 0 auto 4px;';
        
        // Draw preview curve
        const ctx = canvas.getContext('2d');
        ctx.strokeStyle = easing.id === currentEasingFunction ? '#667eea' : '#999';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const easingFunc = easingFunctions[easing.id];
        for (let x = 0; x <= 60; x++) {
          const ratio = x / 60;
          const y = 40 - easingFunc(ratio) * 35;
          if (x === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
        
        // Add label
        const label = document.createElement('div');
        label.textContent = easing.name;
        label.style.cssText = `
          font-size: 10px;
          font-weight: ${easing.id === currentEasingFunction ? 'bold' : 'normal'};
          color: ${easing.id === currentEasingFunction ? '#667eea' : '#666'};
        `;
        
        button.appendChild(canvas);
        button.appendChild(label);
        
        // Click handler
        button.onclick = () => {
          currentEasingFunction = easing.id;
          renderEasingPicker();
          drawAccelerationCurve();
          showToast(`üìà Switched to ${easing.name}`);
        };
        
        // Hover effect
        button.onmouseenter = () => {
          if (easing.id !== currentEasingFunction) {
            button.style.borderColor = '#667eea';
            button.style.background = '#fafbff';
          }
        };
        button.onmouseleave = () => {
          if (easing.id !== currentEasingFunction) {
            button.style.borderColor = '#ddd';
            button.style.background = 'white';
          }
        };
        
        container.appendChild(button);
      });
    }
    
    // Update jog wheel visualization
    function updateJogWheel(event) {
      // Record input time
      jogWheelData.lastInputTime = Date.now();
      
      // Calculate target velocity based on input
      const inputSpeed = event.amount;
      const direction = event.direction === 'up' ? 1 : -1;
      const signedInput = inputSpeed * direction;
      const targetVelocity = inputSpeed * TARGET_MULTIPLIER * direction;
      
      // Record input event for timeline
      recordInputEvent(targetVelocity, inputSpeed * TARGET_MULTIPLIER);
      
      // Calculate acceleration effectiveness using easing curve
      const ratio = Math.abs(inputSpeed) / Math.max(Math.abs(jogWheelData.velocity), 1);
      const normalizedRatio = Math.min(ratio, 3) / 3; // Normalize to 0-1 range (cap at 3x)
      const easingFunc = easingFunctions[currentEasingFunction];
      const effectiveness = easingFunc(normalizedRatio);
      
      // Apply acceleration toward target, scaled by effectiveness
      const velocityDiff = targetVelocity - jogWheelData.velocity;
      jogWheelData.velocity += velocityDiff * ACCELERATION_RATE * effectiveness;
      
      // Update stats
      jogWheelData.totalScrolls++;
      jogWheelData.lastDirection = event.direction;
      
      // Track highest speed in current series
      if (event.amount > jogWheelData.currentSeriesHighest) {
        jogWheelData.currentSeriesHighest = event.amount;
        jogWheelData.highestSpeed = event.amount;
        document.getElementById('jogHighestSpeed').textContent = event.amount;
      }
      
      // Clear existing debounce timer
      if (jogWheelData.debounceTimer) {
        clearTimeout(jogWheelData.debounceTimer);
      }
      
      // Set new debounce timer - reset series after 250ms of no movement
      jogWheelData.debounceTimer = setTimeout(() => {
        jogWheelData.currentSeriesHighest = 0;
      }, 250);
      
      // Update stats display
      document.getElementById('jogScrolls').textContent = jogWheelData.totalScrolls;
      document.getElementById('jogDirection').textContent = event.direction === 'up' ? '‚Üë' : '‚Üì';
      document.getElementById('jogDirection').style.color = event.direction === 'up' ? '#52c41a' : '#ff4d4f';
      
      // Update speed
      document.getElementById('jogSpeed').textContent = event.amount;
      const speedColor = event.amount > 50 ? '#ff4d4f' : event.amount > 20 ? '#faad14' : '#52c41a';
      document.getElementById('jogSpeed').style.color = speedColor;
      
      // Update curve visualization with signed input
      updateCurveVisualization(signedInput * TARGET_MULTIPLIER, jogWheelData.velocity);
      
      // Start physics animation if not already running
      if (!jogWheelData.animationFrame) {
        jogWheelData.animationFrame = requestAnimationFrame(animateJogWheel);
      }
    }
    
    function resetJogPosition() {
      if (jogWheelData.debounceTimer) {
        clearTimeout(jogWheelData.debounceTimer);
      }
      if (jogWheelData.animationFrame) {
        cancelAnimationFrame(jogWheelData.animationFrame);
      }
      jogWheelData = {
        position: 0,
        totalScrolls: 0,
        lastDirection: null,
        highestSpeed: 0,
        currentSeriesHighest: 0,
        debounceTimer: null,
        velocity: 0,
        lastInputTime: 0,
        animationFrame: null
      };
      document.getElementById('jogPosition').textContent = '0';
      document.getElementById('jogProgress').style.strokeDashoffset = '502.65';
      document.getElementById('jogScrolls').textContent = '0';
      document.getElementById('jogDirection').textContent = '‚Äî';
      document.getElementById('jogDirection').style.color = '#333';
      document.getElementById('jogSpeed').textContent = '‚Äî';
      document.getElementById('jogSpeed').style.color = '#333';
      document.getElementById('jogHighestSpeed').textContent = '0';
      showToast('üîÑ Jog wheel position reset');
    }
    
    // Update scroll wheel visualization
    function updateScrollWheel(event) {
      // Record input time
      scrollWheelData.lastInputTime = Date.now();
      
      // Calculate target velocity based on input
      const inputSpeed = event.amount;
      const direction = event.direction === 'up' ? 1 : -1;
      const signedInput = inputSpeed * direction;
      const targetVelocity = inputSpeed * TARGET_MULTIPLIER * direction;
      
      // Record input event for timeline
      recordInputEvent(targetVelocity, inputSpeed * TARGET_MULTIPLIER);
      
      // Calculate acceleration effectiveness using easing curve
      const ratio = Math.abs(inputSpeed) / Math.max(Math.abs(scrollWheelData.velocity), 1);
      const normalizedRatio = Math.min(ratio, 3) / 3; // Normalize to 0-1 range (cap at 3x)
      const easingFunc = easingFunctions[currentEasingFunction];
      const effectiveness = easingFunc(normalizedRatio);
      
      // Apply acceleration toward target, scaled by effectiveness
      const velocityDiff = targetVelocity - scrollWheelData.velocity;
      scrollWheelData.velocity += velocityDiff * ACCELERATION_RATE * effectiveness;
      
      // Update stats
      scrollWheelData.totalScrolls++;
      scrollWheelData.lastDirection = event.direction;
      
      // Track highest speed in current series
      if (event.amount > scrollWheelData.currentSeriesHighest) {
        scrollWheelData.currentSeriesHighest = event.amount;
        scrollWheelData.highestSpeed = event.amount;
        document.getElementById('scrollHighestSpeed').textContent = event.amount;
      }
      
      // Clear existing debounce timer
      if (scrollWheelData.debounceTimer) {
        clearTimeout(scrollWheelData.debounceTimer);
      }
      
      // Set new debounce timer - reset series after 250ms of no movement
      scrollWheelData.debounceTimer = setTimeout(() => {
        scrollWheelData.currentSeriesHighest = 0;
      }, 250);
      
      // Update stats display
      document.getElementById('scrollScrolls').textContent = scrollWheelData.totalScrolls;
      document.getElementById('scrollDirection').textContent = event.direction === 'up' ? '‚Üë' : '‚Üì';
      document.getElementById('scrollDirection').style.color = event.direction === 'up' ? '#52c41a' : '#ff4d4f';
      
      // Update speed
      document.getElementById('scrollSpeed').textContent = event.amount;
      const speedColor = event.amount > 50 ? '#ff4d4f' : event.amount > 20 ? '#faad14' : '#52c41a';
      document.getElementById('scrollSpeed').style.color = speedColor;
      
      // Start physics animation if not already running
      if (!scrollWheelData.animationFrame) {
        scrollWheelData.animationFrame = requestAnimationFrame(animateScrollWheel);
      }
    }
    
    function resetScrollPosition() {
      if (scrollWheelData.debounceTimer) {
        clearTimeout(scrollWheelData.debounceTimer);
      }
      if (scrollWheelData.animationFrame) {
        cancelAnimationFrame(scrollWheelData.animationFrame);
      }
      scrollWheelData = {
        position: 0,
        totalScrolls: 0,
        lastDirection: null,
        highestSpeed: 0,
        currentSeriesHighest: 0,
        debounceTimer: null,
        velocity: 0,
        lastInputTime: 0,
        animationFrame: null
      };
      document.getElementById('scrollPosition').textContent = '0';
      document.getElementById('scrollProgress').style.height = '50%';
      document.getElementById('scrollProgress').style.background = 'linear-gradient(to top, #52c41a, #91d5ff)';
      document.getElementById('scrollScrolls').textContent = '0';
      document.getElementById('scrollDirection').textContent = '‚Äî';
      document.getElementById('scrollDirection').style.color = '#333';
      document.getElementById('scrollSpeed').textContent = '‚Äî';
      document.getElementById('scrollSpeed').style.color = '#333';
      document.getElementById('scrollHighestSpeed').textContent = '0';
      showToast('üîÑ Scroll wheel position reset');
    }
    
    // Physics animation loop for jog wheel
    function animateJogWheel() {
      const now = Date.now();
      const timeSinceInput = now - jogWheelData.lastInputTime;
      
      // Apply friction if no recent input
      if (timeSinceInput > 50) {
        jogWheelData.velocity *= FRICTION;
      }
      
      // Stop if velocity is too small
      if (Math.abs(jogWheelData.velocity) < VELOCITY_THRESHOLD) {
        jogWheelData.velocity = 0;
        jogWheelData.animationFrame = null;
        // Update only velocity, not input
        window.currentDisplayVelocity = 0;
        drawAccelerationCurve();
        return;
      }
      
      // Update position based on velocity
      jogWheelData.position += jogWheelData.velocity;
      
      // Update UI
      document.getElementById('jogPosition').textContent = Math.round(jogWheelData.position);
      
      // Update progress circle
      const normalizedPos = ((jogWheelData.position % 360) + 360) % 360;
      const circumference = 502.65;
      const offset = circumference - (normalizedPos / 360) * circumference;
      document.getElementById('jogProgress').style.strokeDashoffset = offset;
      
      // Update only velocity display, not input
      window.currentDisplayVelocity = jogWheelData.velocity;
      document.getElementById('currentVelocity').textContent = Math.round(Math.abs(jogWheelData.velocity));
      drawAccelerationCurve();
      
      // Continue animation
      jogWheelData.animationFrame = requestAnimationFrame(animateJogWheel);
    }
    
    // Physics animation loop for scroll wheel
    function animateScrollWheel() {
      const now = Date.now();
      const timeSinceInput = now - scrollWheelData.lastInputTime;
      
      // Apply friction if no recent input
      if (timeSinceInput > 50) {
        scrollWheelData.velocity *= FRICTION;
      }
      
      // Stop if velocity is too small
      if (Math.abs(scrollWheelData.velocity) < VELOCITY_THRESHOLD) {
        scrollWheelData.velocity = 0;
        scrollWheelData.animationFrame = null;
        return;
      }
      
      // Update position based on velocity
      scrollWheelData.position += scrollWheelData.velocity;
      
      // Update UI
      document.getElementById('scrollPosition').textContent = Math.round(scrollWheelData.position);
      
      // Update vertical bar
      const maxVisualRange = 500;
      const normalizedPos = Math.max(-maxVisualRange, Math.min(maxVisualRange, scrollWheelData.position));
      const percentage = ((normalizedPos / maxVisualRange) * 50) + 50;
      document.getElementById('scrollProgress').style.height = percentage + '%';
      
      // Update color
      if (scrollWheelData.position > 0) {
        document.getElementById('scrollProgress').style.background = 'linear-gradient(to top, #52c41a, #91d5ff)';
      } else {
        document.getElementById('scrollProgress').style.background = 'linear-gradient(to top, #ff4d4f, #ffa39e)';
      }
      
      // Continue animation
      scrollWheelData.animationFrame = requestAnimationFrame(animateScrollWheel);
    }
    
    // Update log
    function updateLog(report) {
      const logDiv = document.getElementById('log');
      
      report.events.forEach((event, idx) => {
        const time = new Date(report.timestamp).toLocaleTimeString();
        const entryId = `log-${Date.now()}-${idx}`;
        let message = '';
        let className = event.type;
        let actions = '';
        
        if (event.type === 'button') {
          const isKnown = !event.name.startsWith('Unknown Button');
          if (isKnown) className += ' known';
          const checkmark = isKnown ? ' ‚úì' : '';
          
          // Show bit value if available (helps identify multiple buttons in same byte)
          const bitInfo = event.bitValue ? ` (bit: ${event.bitValue})` : '';
          message = `<span class="event-badge button">BUTTON</span> ${event.name}${checkmark} ${event.action.toUpperCase()}${bitInfo}`;
          
          // Only show "Add Mapping" for unknown buttons
          if (event.name.startsWith('Unknown Button')) {
            const byteInfo = event.bitValue ? `[byte ${event.byte}, value ${event.bitValue}]` : `[${event.byte}]`;
            const bitValueParam = event.bitValue || 'null';
            actions = `
              <div class="log-actions">
                <input type="text" id="${entryId}-name" placeholder="Enter button name..." 
                       onkeypress="if(event.key === 'Enter') quickAddButton(${event.byte}, '${entryId}-name', ${bitValueParam})" />
                <button onclick="quickAddButton(${event.byte}, '${entryId}-name', ${bitValueParam})">
                  ‚ûï Map Button ${byteInfo}
                </button>
              </div>
            `;
          } else {
            // Show confirmation for mapped buttons
            const mappingInfo = event.bitValue ? `byte ${event.byte}, bit ${event.bitValue}` : `byte ${event.byte}`;
            actions = `
              <div style="color: #52c41a; font-size: 12px; margin-top: 4px;">
                Mapped control (${mappingInfo})
              </div>
            `;
          }
        } else if (event.type === 'scroll') {
          const isKnown = !event.name.startsWith('Unknown Scroll');
          if (isKnown) className += ' known';
          const checkmark = isKnown ? ' ‚úì' : '';
          
          // Show raw velocity value if available
          const velocityInfo = event.rawValue ? ` [velocity: ${event.rawValue}]` : '';
          message = `<span class="event-badge scroll">SCROLL</span> ${event.name}${checkmark} ${event.direction.toUpperCase()} by ${event.amount}${velocityInfo} (pos: ${event.position})`;
          
          // Update jog wheel visualization if this is the jog wheel
          if (event.name === 'Jog' || event.name.includes('Jog')) {
            updateJogWheel(event);
          }
          
          // Update scroll wheel visualization if this is the scroll wheel
          if (event.name === 'Scroll' || event.name.includes('Scroll')) {
            updateScrollWheel(event);
          }
          
          // Only show "Add Mapping" for unknown scrolls
          if (event.name.startsWith('Unknown Scroll')) {
            actions = `
              <div class="log-actions">
                <input type="text" id="${entryId}-name" placeholder="Enter wheel name..." 
                       onkeypress="if(event.key === 'Enter') quickAddScroll(${event.byte}, '${entryId}-name')" />
                <button onclick="quickAddScroll(${event.byte}, '${entryId}-name')">
                  ‚ûï Map Scroll Wheel [${event.byte}]
                </button>
              </div>
            `;
          } else {
            // Show confirmation for mapped scrolls
            actions = `
              <div style="color: #52c41a; font-size: 12px; margin-top: 4px;">
                Mapped control (byte ${event.byte})
              </div>
            `;
          }
        } else if (event.type === 'value') {
          message = `<span class="event-badge value">VALUE</span> ${event.name}: ${event.prev} ‚Üí ${event.curr}`;
        }
        
        logEntries.unshift(`
          <div class="log-entry ${className}">
            <span class="timestamp">${time}</span> ${message}
            ${actions}
          </div>
        `);
      });
      
      // Keep only last MAX_LOG_ENTRIES
      logEntries = logEntries.slice(0, MAX_LOG_ENTRIES);
      logDiv.innerHTML = logEntries.join('');
    }
    
    // Toast notification
    function showToast(message, type = 'success') {
      const toast = document.createElement('div');
      toast.className = 'toast';
      if (type === 'warning') toast.classList.add('warning');
      if (type === 'error') toast.classList.add('error');
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.style.animation = 'slideIn 0.3s ease-out reverse';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }
    
    // Quick add functions
    async function quickAddButton(byte, inputId, bitValue = null) {
      const input = document.getElementById(inputId);
      const name = input.value.trim();
      
      if (!name) {
        showToast('‚ö†Ô∏è Please enter a button name', 'warning');
        input.focus();
        return;
      }
      
      // Use byte:bitValue as key if bitValue is provided (for multiple buttons on same byte)
      const key = bitValue ? `${byte}:${bitValue}` : byte;
      
      // Update local config
      config.buttons[key] = name;
      renderMappings();
      
      // Auto-save to server so future events use this mapping
      await fetch('/api/config', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
      });
      
      // Clear the input
      input.value = '';
      input.style.border = '2px solid #52c41a';
      setTimeout(() => {
        input.style.border = '1px solid #555';
      }, 1000);
      
      // Show success message
      const keyInfo = bitValue ? `[byte ${byte}, bit ${bitValue}]` : `[${byte}]`;
      showToast(`‚úÖ Button ${keyInfo} ‚Üí "${name}" (saved & active!)`);
    }
    
    async function quickAddScroll(byte, inputId) {
      const input = document.getElementById(inputId);
      const name = input.value.trim();
      
      if (!name) {
        showToast('‚ö†Ô∏è Please enter a wheel name', 'warning');
        input.focus();
        return;
      }
      
      // Update local config
      config.scrollWheels[byte] = name;
      renderMappings();
      
      // Auto-save to server so future events use this mapping
      await fetch('/api/config', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
      });
      
      // Clear the input
      input.value = '';
      input.style.border = '2px solid #52c41a';
      setTimeout(() => {
        input.style.border = '1px solid #555';
      }, 1000);
      
      // Show success message
      showToast(`‚úÖ Scroll [${byte}] ‚Üí "${name}" (saved & active!)`);
    }
    
    function clearLog() {
      logEntries = [];
      document.getElementById('log').innerHTML = '';
      showToast('üóëÔ∏è Log cleared');
    }
  </script>
</body>
</html>
