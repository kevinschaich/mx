<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MX Dialpad Configuration</title>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1800px;
      margin: 0 auto;
    }
    
    h1 {
      color: white;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }
    
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    @media (min-width: 1200px) {
      .grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }
    
    @media (max-width: 768px) {
      .grid {
        grid-template-columns: 1fr;
      }
      
      h1 {
        font-size: 1.8em;
      }
    }
    
    .card {
      background: white;
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    
    .card h2 {
      margin-bottom: 16px;
      color: #333;
      font-size: 1.5em;
      border-bottom: 2px solid #667eea;
      padding-bottom: 8px;
    }
    
    .status {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff4d4f;
      animation: pulse 2s infinite;
    }
    
    .status-dot.connected {
      background: #52c41a;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    button.primary {
      background: #667eea;
      color: white;
    }
    
    button.danger {
      background: #ff4d4f;
      color: white;
    }
    
    button.success {
      background: #52c41a;
      color: white;
    }
    
    .mapping-item {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
      align-items: center;
    }
    
    .mapping-item input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #d9d9d9;
      border-radius: 6px;
      font-size: 14px;
    }
    
    .mapping-item input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .mapping-item button {
      padding: 8px 12px;
    }
    
    .add-mapping {
      margin-top: 16px;
    }
    
    .log {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 16px;
      border-radius: 8px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 13px;
      max-height: 500px;
      overflow-y: auto;
      line-height: 1.6;
    }
    
    .log-entry {
      margin-bottom: 12px;
      padding: 8px;
      background: #2d2d2d;
      border-radius: 4px;
      border-left: 3px solid #667eea;
    }
    
    .log-entry.button {
      border-left-color: #52c41a;
    }
    
    .log-entry.scroll {
      border-left-color: #faad14;
    }
    
    .log-entry.known {
      background: #1f3a1f;
      border-left-width: 4px;
    }
    
    .timestamp {
      color: #888;
      font-size: 11px;
    }
    
    .event-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      margin-right: 8px;
    }
    
    .event-badge.button { background: #52c41a; color: white; }
    .event-badge.scroll { background: #faad14; color: white; }
    .event-badge.value { background: #1890ff; color: white; }
    
    .log-actions {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .log-actions button {
      padding: 4px 10px;
      font-size: 11px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .log-actions button:hover {
      background: #5568d3;
    }
    
    .log-actions input {
      padding: 4px 8px;
      font-size: 12px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #1e1e1e;
      color: #d4d4d4;
      width: 150px;
    }
    
    .log-actions input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #52c41a;
      color: white;
      padding: 16px 24px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      animation: slideIn 0.3s ease-out;
      font-weight: 600;
    }
    
    .toast.warning {
      background: #faad14;
    }
    
    .toast.error {
      background: #ff4d4f;
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    .clear-log {
      margin-top: 12px;
    }
    
    .full-width {
      grid-column: 1 / -1;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéõÔ∏è MX Dialpad Configuration</h1>
    
    <div class="grid">
      <!-- JOG WHEEL ROW -->
      <!-- Jog Wheel: Velocity & Input -->
      <div class="card">
        <h2>üéØ Jog Wheel: Velocity & Input</h2>
        <div style="margin-bottom: 16px;">
          <div style="display: flex; gap: 20px;">
            <!-- Friction Control -->
            <div style="flex: 1;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <label style="font-weight: 500;">Friction:</label>
                <span style="font-weight: bold; color: #667eea;" id="frictionValue">Loading...</span>
              </div>
              <input type="range" id="frictionSlider" min="5" max="100" value="50" step="1"
                     oninput="updateFriction(this.value)"
                     style="width: 100%; cursor: pointer;">
              <div style="font-size: 11px; color: #999; margin-top: 4px;">
                Lower = more momentum (5-100)
              </div>
            </div>
            <!-- Sensitivity Control -->
            <div style="flex: 1;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <label style="font-weight: 500;">Sensitivity:</label>
                <span style="font-weight: bold; color: #52c41a;" id="sensitivityValue">Loading...</span>
              </div>
              <input type="range" id="sensitivitySlider" min="1" max="100" value="50" step="1"
                     oninput="updateSensitivity(this.value)"
                     style="width: 100%; cursor: pointer;">
              <div style="font-size: 11px; color: #999; margin-top: 4px;">
                Output movement scale (1-100)
              </div>
            </div>
          </div>
        </div>
        <div style="text-align: center; background: #f9f9f9; padding: 16px; border-radius: 8px;">
          <canvas id="jogCurveCanvas" width="300" height="200" style="border: 1px solid #ddd; border-radius: 4px; background: white;"></canvas>
          <div style="margin-top: 12px; display: flex; justify-content: space-around; font-size: 12px;">
            <div>
              <div style="color: #999;">Raw Input</div>
              <div style="font-size: 20px; font-weight: bold; color: #faad14;" id="jogCurrentInput">0</div>
            </div>
            <div>
              <div style="color: #999;">Velocity</div>
              <div style="font-size: 20px; font-weight: bold; color: #667eea;" id="jogCurrentVelocity">0</div>
            </div>
            <div>
              <div style="color: #999;">Multiplier</div>
              <div style="font-size: 20px; font-weight: bold; color: #52c41a;" id="jogEffectiveness">0.0x</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Jog Wheel: Timeline -->
      <div class="card">
        <h2>üéØ Jog Wheel: Timeline</h2>
        <div style="text-align: center; background: #f9f9f9; padding: 16px; border-radius: 8px;">
          <canvas id="jogTimelineCanvas" width="300" height="200" style="border: 1px solid #ddd; border-radius: 4px; background: white;"></canvas>
          <div style="margin-top: 12px; display: flex; justify-content: space-around; font-size: 11px;">
            <div style="display: flex; align-items: center; gap: 4px;">
              <div style="width: 12px; height: 12px; background: #faad14; border-radius: 2px;"></div>
              <span>Raw Input</span>
            </div>
            <div style="display: flex; align-items: center; gap: 4px;">
              <div style="width: 12px; height: 12px; background: #667eea; border-radius: 2px;"></div>
              <span>Velocity (with friction)</span>
            </div>
          </div>
          <div style="margin-top: 8px; font-size: 11px; color: #999;">Last 3 seconds</div>
        </div>
      </div>
      
      <!-- Jog Wheel: Position Visualization -->
      <div class="card">
        <h2>üéØ Jog Wheel: Position</h2>
        <div style="text-align: center;">
          <svg width="200" height="200" style="margin: 0 auto; display: block;">
            <circle cx="100" cy="100" r="80" fill="none" stroke="#e0e0e0" stroke-width="10"/>
            <circle id="jogProgress" cx="100" cy="100" r="80" fill="none" stroke="#667eea" stroke-width="10"
                    stroke-dasharray="502.65" stroke-dashoffset="502.65"
                    transform="rotate(-90 100 100)" stroke-linecap="round"/>
            <text x="100" y="100" text-anchor="middle" dy=".3em" font-size="24" font-weight="bold" fill="#333" id="jogPosition">0</text>
          </svg>
          <div style="margin-top: 12px; display: flex; justify-content: space-around;">
            <div>
              <div style="font-size: 11px; color: #999;">Total Scrolls</div>
              <div style="font-size: 18px; font-weight: bold;" id="jogScrolls">0</div>
            </div>
            <div>
              <div style="font-size: 11px; color: #999;">Last Speed</div>
              <div style="font-size: 18px; font-weight: bold;" id="jogSpeed">‚Äî</div>
            </div>
            <div>
              <div style="font-size: 11px; color: #999;">Highest Speed</div>
              <div style="font-size: 18px; font-weight: bold; color: #ff4d4f;" id="jogHighestSpeed">0</div>
            </div>
            <div>
              <div style="font-size: 11px; color: #999;">Direction</div>
              <div style="font-size: 18px; font-weight: bold;" id="jogDirection">‚Äî</div>
            </div>
          </div>
          <button onclick="resetJogPosition()" style="margin-top: 12px; padding: 6px 16px; font-size: 12px; background: #faad14; color: white; border: none; border-radius: 4px; cursor: pointer;">
            Reset Position
          </button>
        </div>
      </div>
      
      <!-- SCROLL WHEEL ROW -->
      <!-- Scroll Wheel: Velocity & Input -->
      <div class="card">
        <h2>üîÑ Scroll Wheel: Velocity & Input</h2>
        <div style="text-align: center; background: #f9f9f9; padding: 16px; border-radius: 8px;">
          <canvas id="scrollCurveCanvas" width="300" height="200" style="border: 1px solid #ddd; border-radius: 4px; background: white;"></canvas>
          <div style="margin-top: 12px; display: flex; justify-content: space-around; font-size: 12px;">
            <div>
              <div style="color: #999;">Raw Input</div>
              <div style="font-size: 20px; font-weight: bold; color: #faad14;" id="scrollCurrentInput">0</div>
            </div>
            <div>
              <div style="color: #999;">Velocity</div>
              <div style="font-size: 20px; font-weight: bold; color: #667eea;" id="scrollCurrentVelocity">0</div>
            </div>
            <div>
              <div style="color: #999;">Multiplier</div>
              <div style="font-size: 20px; font-weight: bold; color: #52c41a;" id="scrollEffectiveness">0.0x</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Scroll Wheel: Timeline -->
      <div class="card">
        <h2>üîÑ Scroll Wheel: Timeline</h2>
        <div style="text-align: center; background: #f9f9f9; padding: 16px; border-radius: 8px;">
          <canvas id="scrollTimelineCanvas" width="300" height="200" style="border: 1px solid #ddd; border-radius: 4px; background: white;"></canvas>
          <div style="margin-top: 12px; display: flex; justify-content: space-around; font-size: 11px;">
            <div style="display: flex; align-items: center; gap: 4px;">
              <div style="width: 12px; height: 12px; background: #faad14; border-radius: 2px;"></div>
              <span>Raw Input</span>
            </div>
            <div style="display: flex; align-items: center; gap: 4px;">
              <div style="width: 12px; height: 12px; background: #667eea; border-radius: 2px;"></div>
              <span>Velocity (with friction)</span>
            </div>
          </div>
          <div style="margin-top: 8px; font-size: 11px; color: #999;">Last 3 seconds</div>
        </div>
      </div>
      
      <!-- Scroll Wheel: Position Visualization -->
      <div class="card">
        <h2>üîÑ Scroll Wheel: Position</h2>
        <div style="text-align: center;">
          <svg width="200" height="200" style="margin: 0 auto; display: block;">
            <circle cx="100" cy="100" r="80" fill="none" stroke="#e0e0e0" stroke-width="10"/>
            <circle id="scrollProgress" cx="100" cy="100" r="80" fill="none" stroke="#52c41a" stroke-width="10"
                    stroke-dasharray="502.65" stroke-dashoffset="502.65"
                    transform="rotate(-90 100 100)" stroke-linecap="round"/>
            <text x="100" y="100" text-anchor="middle" dy=".3em" font-size="24" font-weight="bold" fill="#333" id="scrollPosition">0</text>
          </svg>
          <div style="margin-top: 12px; display: flex; justify-content: space-around;">
            <div>
              <div style="font-size: 11px; color: #999;">Total Scrolls</div>
              <div style="font-size: 18px; font-weight: bold;" id="scrollScrolls">0</div>
            </div>
            <div>
              <div style="font-size: 11px; color: #999;">Last Speed</div>
              <div style="font-size: 18px; font-weight: bold;" id="scrollSpeed">‚Äî</div>
            </div>
            <div>
              <div style="font-size: 11px; color: #999;">Highest Speed</div>
              <div style="font-size: 18px; font-weight: bold; color: #ff4d4f;" id="scrollHighestSpeed">0</div>
            </div>
            <div>
              <div style="font-size: 11px; color: #999;">Direction</div>
              <div style="font-size: 18px; font-weight: bold;" id="scrollDirection">‚Äî</div>
            </div>
          </div>
          <button onclick="resetScrollPosition()" style="margin-top: 12px; padding: 6px 16px; font-size: 12px; background: #faad14; color: white; border: none; border-radius: 4px; cursor: pointer;">
            Reset Position
          </button>
        </div>
      </div>
      
      <!-- BOTTOM SECTION -->
      <!-- Status Card -->
      <div class="card">
        <h2>Device Status</h2>
        <div class="status">
          <div class="status-dot" id="statusDot"></div>
          <span id="statusText">Disconnected</span>
        </div>
        <p>Reports received: <strong id="reportCount">0</strong></p>
      </div>
      
      <!-- Buttons Mapping -->
      <div class="card">
        <h2>Actions</h2>
        <p style="font-size: 13px; color: #666; margin-bottom: 12px;">
          üí° Physics settings (friction/sensitivity) and quick-add mappings auto-save! Use this button if you manually edit mappings.
        </p>
        <button class="success" onclick="saveConfig()">üíæ Save Configuration</button>
        <button class="danger" onclick="clearConfig()">üóëÔ∏è Clear All Mappings</button>
      </div>
      
      <!-- Live Log -->
      <div class="card full-width">
        <h2>Live Event Log</h2>
        <div class="log" id="log"></div>
        <button class="primary clear-log" onclick="clearLog()">Clear Log</button>
      </div>
    </div>
  </div>

  <script>
    const socket = io();
    let config = { buttons: {}, scrollWheels: {} };
    let logEntries = [];
    const MAX_LOG_ENTRIES = 100;
    let jogWheelData = {
      position: 0,
      totalScrolls: 0,
      lastDirection: null,
      highestSpeed: 0,
      currentSeriesHighest: 0,
      debounceTimer: null,
      velocity: 0,
      lastInputTime: 0,
      animationFrame: null
    };
    let scrollWheelData = {
      position: 0,
      totalScrolls: 0,
      lastDirection: null,
      highestSpeed: 0,
      currentSeriesHighest: 0,
      debounceTimer: null,
      velocity: 0,
      lastInputTime: 0,
      animationFrame: null
    };
    
    // Timeline data tracking (separate for each wheel)
    const TIMELINE_DURATION = 3000; // 3 seconds in ms
    let jogTimelineData = {
      inputs: [], // [{time, value}]
      velocities: [], // [{time, value}]
      lastUpdateTime: Date.now()
    };
    let scrollTimelineData = {
      inputs: [], // [{time, value}]
      velocities: [], // [{time, value}]
      lastUpdateTime: Date.now()
    };
    
    // Input display tracking (for bar charts - separate for each wheel)
    let jogInputDisplayData = {
      value: 0,
      lastInputTime: 0,
      holdDuration: 200 // Hold input display for 200ms after last input
    };
    let scrollInputDisplayData = {
      value: 0,
      lastInputTime: 0,
      holdDuration: 200
    };
    
    // Physics constants
    const VELOCITY_THRESHOLD = 0.1; // Stop animating below this velocity
    const TARGET_MULTIPLIER = 2.5; // How much to scale input speed for target velocity
    
    // Global friction setting (loaded from config)
    let globalFriction = null;
    
    // Global sensitivity setting (loaded from config)
    let globalSensitivity = null;
    
    // Socket events
    socket.on('connect', () => {
      console.log('‚úÖ Socket.IO connected to server');
    });
    
    socket.on('connect_error', (error) => {
      console.error('‚ùå Socket.IO connection error:', error);
      showToast('‚ö†Ô∏è WebSocket connection failed', 'error');
    });
    
    socket.on('disconnect', (reason) => {
      console.warn('‚ö†Ô∏è Socket.IO disconnected:', reason);
      updateStatus({ connected: false, reportCount: 0 });
    });
    
    socket.on('config', (data) => {
      console.log('üìù Socket received config:', data);
      config = data;
      renderMappings();
      loadPhysicsSettings();
    });
    
    // Load physics settings from config
    function loadPhysicsSettings() {
      console.log('üéõÔ∏è  loadPhysicsSettings called');
      console.log('üéõÔ∏è  Current config object:', JSON.stringify(config));
      
      if (!config) {
        console.error('‚ùå Config is null/undefined!');
        return;
      }
      
      // Load friction from config (default to 50 if not set)
      const friction = config.friction !== undefined && config.friction !== null ? config.friction : 50;
      console.log(`üéõÔ∏è  Friction value from config: ${config.friction} -> using: ${friction}`);
      globalFriction = friction;
      
      const frictionSlider = document.getElementById('frictionSlider');
      const frictionValue = document.getElementById('frictionValue');
      
      console.log(`üéõÔ∏è  Friction slider element:`, frictionSlider);
      console.log(`üéõÔ∏è  Friction value element:`, frictionValue);
      
      if (frictionSlider && frictionValue) {
        console.log(`üéõÔ∏è  Setting friction slider to: ${friction}`);
        frictionSlider.value = friction;
        console.log(`üéõÔ∏è  Setting friction display to: ${friction}`);
        frictionValue.textContent = friction;
        console.log(`‚úÖ Friction set to ${friction}, slider.value=${frictionSlider.value}`);
      } else {
        console.error('‚ùå Could not find friction elements!');
      }
      
      // Load sensitivity from config (default to 50 if not set)
      const sensitivity = config.sensitivity !== undefined && config.sensitivity !== null ? config.sensitivity : 50;
      console.log(`üéõÔ∏è  Sensitivity value from config: ${config.sensitivity} -> using: ${sensitivity}`);
      globalSensitivity = sensitivity;
      
      const sensitivitySlider = document.getElementById('sensitivitySlider');
      const sensitivityValue = document.getElementById('sensitivityValue');
      
      console.log(`üéõÔ∏è  Sensitivity slider element:`, sensitivitySlider);
      console.log(`üéõÔ∏è  Sensitivity value element:`, sensitivityValue);
      
      if (sensitivitySlider && sensitivityValue) {
        console.log(`üéõÔ∏è  Setting sensitivity slider to: ${sensitivity}`);
        sensitivitySlider.value = sensitivity;
        console.log(`üéõÔ∏è  Setting sensitivity display to: ${sensitivity}`);
        sensitivityValue.textContent = sensitivity;
        console.log(`‚úÖ Sensitivity set to ${sensitivity}, slider.value=${sensitivitySlider.value}`);
      } else {
        console.error('‚ùå Could not find sensitivity elements!');
      }
      
      console.log(`üéõÔ∏è  Final physics state: friction=${globalFriction}, sensitivity=${globalSensitivity}`);
    }
    
    socket.on('status', (data) => {
      updateStatus(data);
      console.log('üìä Status update:', data);
    });
    
    socket.on('report', (report) => {
      updateLog(report);
    });
    
    // Update status
    function updateStatus(status) {
      const dot = document.getElementById('statusDot');
      const text = document.getElementById('statusText');
      const count = document.getElementById('reportCount');
      
      if (status.connected) {
        dot.classList.add('connected');
        text.textContent = 'Connected';
      } else {
        dot.classList.remove('connected');
        text.textContent = 'Disconnected';
      }
      
      count.textContent = status.reportCount;
    }
    
    // Render mappings
    function renderMappings() {
      const buttonContainer = document.getElementById('buttonMappings');
      const scrollContainer = document.getElementById('scrollMappings');
      
      // Skip rendering if containers don't exist (they were removed from UI)
      if (!buttonContainer || !scrollContainer) {
        console.log('‚ö†Ô∏è  Mapping containers not found in DOM, skipping render');
        return;
      }
      
      buttonContainer.innerHTML = '';
      scrollContainer.innerHTML = '';
      
      Object.entries(config.buttons || {}).forEach(([key, name]) => {
        const displayKey = key.includes(':') ? `Byte ${key.split(':')[0]} bit ${key.split(':')[1]}` : `Byte ${key}`;
        buttonContainer.innerHTML += `
          <div class="mapping-item">
            <input type="text" value="${displayKey}" disabled style="width: 150px;">
            <input type="text" value="${name}" onchange="updateButtonMapping('${key}', this.value)">
            <button class="danger" onclick="removeButtonMapping('${key}')">‚úï</button>
          </div>
        `;
      });
      
      Object.entries(config.scrollWheels || {}).forEach(([byte, name]) => {
        scrollContainer.innerHTML += `
          <div class="mapping-item">
            <input type="text" value="Byte ${byte}" disabled style="width: 100px;">
            <input type="text" value="${name}" onchange="updateScrollMapping(${byte}, this.value)">
            <button class="danger" onclick="removeScrollMapping(${byte})">‚úï</button>
          </div>
        `;
      });
    }
    
    // Add mappings
    function addButtonMapping() {
      const byte = document.getElementById('newButtonByte').value;
      const bit = document.getElementById('newButtonBit').value;
      const name = document.getElementById('newButtonName').value;
      
      if (byte && name) {
        const key = bit ? `${byte}:${bit}` : byte;
        config.buttons[key] = name;
        document.getElementById('newButtonByte').value = '';
        document.getElementById('newButtonBit').value = '';
        document.getElementById('newButtonName').value = '';
        renderMappings();
      }
    }
    
    function addScrollMapping() {
      const byte = document.getElementById('newScrollByte').value;
      const name = document.getElementById('newScrollName').value;
      
      if (byte && name) {
        config.scrollWheels[byte] = name;
        document.getElementById('newScrollByte').value = '';
        document.getElementById('newScrollName').value = '';
        renderMappings();
      }
    }
    
    // Update mappings
    function updateButtonMapping(key, name) {
      config.buttons[key] = name;
    }
    
    function updateScrollMapping(byte, name) {
      config.scrollWheels[byte] = name;
    }
    
    // Remove mappings
    function removeButtonMapping(key) {
      delete config.buttons[key];
      renderMappings();
    }
    
    function removeScrollMapping(byte) {
      delete config.scrollWheels[byte];
      renderMappings();
    }
    
    // Save config
    async function saveConfig() {
      // Ensure friction and sensitivity are included in the config
      config.friction = globalFriction;
      config.sensitivity = globalSensitivity;
      
      const response = await fetch('/api/config', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
      });
      
      if (response.ok) {
        showToast('‚úÖ Configuration saved successfully!');
      } else {
        showToast('‚ùå Failed to save configuration', 'error');
      }
    }
    
    // Clear config
    function clearConfig() {
      if (confirm('‚ö†Ô∏è Are you sure you want to clear all mappings?\n\nThis will remove all button and scroll wheel mappings.\n\nDon\'t forget to save after clearing!')) {
        config = { 
          buttons: {}, 
          scrollWheels: {},
          friction: globalFriction,
          sensitivity: globalSensitivity
        };
        renderMappings();
        showToast('üóëÔ∏è All mappings cleared (save to persist)');
      }
    }
    
    // Draw timeline chart showing input vs velocity over time
    // Draw timeline chart showing input vs velocity over time for JOG wheel
    function drawJogTimeline() {
      const canvas = document.getElementById('jogTimelineCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 30;
      const centerY = height / 2;
      const now = Date.now();
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw center horizontal axis
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, centerY);
      ctx.lineTo(width - padding, centerY);
      ctx.stroke();
      
      // Draw vertical axis
      ctx.strokeStyle = '#ccc';
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.stroke();
      
      // Draw time grid lines (every 500ms)
      ctx.strokeStyle = '#f0f0f0';
      ctx.lineWidth = 1;
      for (let i = 1; i <= 6; i++) {
        const x = padding + (i * (width - 2 * padding) / 6);
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      }
      
      // Draw axis labels
      ctx.fillStyle = '#666';
      ctx.font = '10px sans-serif';
      ctx.fillText('-3s', padding - 5, height - padding + 15);
      ctx.fillText('now', width - padding - 10, height - padding + 15);
      
      // Clean old data
      const cutoffTime = now - TIMELINE_DURATION;
      jogTimelineData.inputs = jogTimelineData.inputs.filter(d => d.time > cutoffTime);
      jogTimelineData.velocities = jogTimelineData.velocities.filter(d => d.time > cutoffTime);
      
      // Helper to convert time to x position
      const timeToX = (time) => {
        const age = now - time;
        const ratio = 1 - (age / TIMELINE_DURATION);
        return padding + ratio * (width - 2 * padding);
      };
      
      // Helper to convert value to y position
      const valueToY = (value) => {
        const maxValue = 100;
        const ratio = Math.max(-1, Math.min(1, value / maxValue));
        return centerY - ratio * (centerY - padding);
      };
      
      // Draw velocity line (smooth)
      if (jogTimelineData.velocities.length > 1) {
        ctx.strokeStyle = '#667eea';
        ctx.lineWidth = 2;
        ctx.beginPath();
        jogTimelineData.velocities.forEach((d, i) => {
          const x = timeToX(d.time);
          const y = valueToY(d.value);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();
      }
      
      // Draw input spikes (as bars)
      ctx.fillStyle = '#faad14';
      jogTimelineData.inputs.forEach(d => {
        const x = timeToX(d.time);
        const y = valueToY(d.value);
        const barWidth = 3;
        
        // Draw bar from center to value
        ctx.fillRect(x - barWidth/2, Math.min(centerY, y), barWidth, Math.abs(centerY - y));
      });
    }
    
    // Draw timeline chart showing input vs velocity over time for SCROLL wheel
    function drawScrollTimeline() {
      const canvas = document.getElementById('scrollTimelineCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 30;
      const centerY = height / 2;
      const now = Date.now();
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw center horizontal axis
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, centerY);
      ctx.lineTo(width - padding, centerY);
      ctx.stroke();
      
      // Draw vertical axis
      ctx.strokeStyle = '#ccc';
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.stroke();
      
      // Draw time grid lines (every 500ms)
      ctx.strokeStyle = '#f0f0f0';
      ctx.lineWidth = 1;
      for (let i = 1; i <= 6; i++) {
        const x = padding + (i * (width - 2 * padding) / 6);
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      }
      
      // Draw axis labels
      ctx.fillStyle = '#666';
      ctx.font = '10px sans-serif';
      ctx.fillText('-3s', padding - 5, height - padding + 15);
      ctx.fillText('now', width - padding - 10, height - padding + 15);
      
      // Clean old data
      const cutoffTime = now - TIMELINE_DURATION;
      scrollTimelineData.inputs = scrollTimelineData.inputs.filter(d => d.time > cutoffTime);
      scrollTimelineData.velocities = scrollTimelineData.velocities.filter(d => d.time > cutoffTime);
      
      // Helper to convert time to x position
      const timeToX = (time) => {
        const age = now - time;
        const ratio = 1 - (age / TIMELINE_DURATION);
        return padding + ratio * (width - 2 * padding);
      };
      
      // Helper to convert value to y position
      const valueToY = (value) => {
        const maxValue = 100;
        const ratio = Math.max(-1, Math.min(1, value / maxValue));
        return centerY - ratio * (centerY - padding);
      };
      
      // Draw velocity line (smooth)
      if (scrollTimelineData.velocities.length > 1) {
        ctx.strokeStyle = '#667eea';
        ctx.lineWidth = 2;
        ctx.beginPath();
        scrollTimelineData.velocities.forEach((d, i) => {
          const x = timeToX(d.time);
          const y = valueToY(d.value);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();
      }
      
      // Draw input spikes (as bars)
      ctx.fillStyle = '#faad14';
      scrollTimelineData.inputs.forEach(d => {
        const x = timeToX(d.time);
        const y = valueToY(d.value);
        const barWidth = 3;
        
        // Draw bar from center to value
        ctx.fillRect(x - barWidth/2, Math.min(centerY, y), barWidth, Math.abs(centerY - y));
      });
    }
    
    // Legacy function for backwards compatibility
    function drawTimeline() {
      drawJogTimeline();
    }
    
    // Update jog timeline with current data
    function updateJogTimeline() {
      const now = Date.now();
      
      // Add current velocity (for smooth line)
      if (jogWheelData.velocity !== 0) {
        jogTimelineData.velocities.push({ time: now, value: jogWheelData.velocity });
      } else if (jogTimelineData.velocities.length > 0) {
        // Add zero point when velocity stops
        const lastVelocity = jogTimelineData.velocities[jogTimelineData.velocities.length - 1];
        if (lastVelocity.value !== 0) {
          jogTimelineData.velocities.push({ time: now, value: 0 });
        }
      }
      
      // Redraw
      drawJogTimeline();
    }
    
    // Update scroll timeline with current data
    function updateScrollTimeline() {
      const now = Date.now();
      
      // Add current velocity (for smooth line)
      if (scrollWheelData.velocity !== 0) {
        scrollTimelineData.velocities.push({ time: now, value: scrollWheelData.velocity });
      } else if (scrollTimelineData.velocities.length > 0) {
        // Add zero point when velocity stops
        const lastVelocity = scrollTimelineData.velocities[jogTimelineData.velocities.length - 1];
        if (lastVelocity.value !== 0) {
          scrollTimelineData.velocities.push({ time: now, value: 0 });
        }
      }
      
      // Redraw
      drawScrollTimeline();
    }
    
    // Legacy function for backwards compatibility
    function updateTimeline() {
      updateJogTimeline();
      updateScrollTimeline();
    }
    
    // Record input event on jog timeline
    function recordJogInputEvent(velocity, inputAmount) {
      const now = Date.now();
      const signedInput = velocity >= 0 ? inputAmount : -inputAmount;
      jogTimelineData.inputs.push({ time: now, value: signedInput });
    }
    
    // Record input event on scroll timeline
    function recordScrollInputEvent(velocity, inputAmount) {
      const now = Date.now();
      const signedInput = velocity >= 0 ? inputAmount : -inputAmount;
      scrollTimelineData.inputs.push({ time: now, value: signedInput });
    }
    
    // Legacy function for backwards compatibility
    function recordInputEvent(velocity, inputAmount) {
      recordJogInputEvent(velocity, inputAmount);
    }
    
    // Draw simple velocity vs input bars for JOG wheel
    function drawJogCurve() {
      const canvas = document.getElementById('jogCurveCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 40;
      const centerY = height / 2;
      const barWidth = 50;
      const spacing = 100;
      const now = Date.now();
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw center line
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, centerY);
      ctx.lineTo(width - padding, centerY);
      ctx.stroke();
      
      // Draw scale marks
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 1;
      ctx.font = '10px sans-serif';
      ctx.fillStyle = '#999';
      for (let i = -100; i <= 100; i += 50) {
        if (i === 0) continue;
        const y = centerY - (i / 100) * (centerY - padding);
        ctx.beginPath();
        ctx.moveTo(padding - 5, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
        ctx.fillText(i > 0 ? `+${i}` : i.toString(), 5, y + 3);
      }
      
      // Check if we should still show the input or fade it
      const timeSinceInput = now - jogInputDisplayData.lastInputTime;
      let inputValue = 0;
      
      if (timeSinceInput < jogInputDisplayData.holdDuration) {
        inputValue = jogInputDisplayData.value;
      } else {
        inputValue = 0;
      }
      
      // Get velocity with smooth interpolation
      if (!window.jogSmoothDisplayVelocity) window.jogSmoothDisplayVelocity = 0;
      const targetVelocity = window.jogCurrentDisplayVelocity || 0;
      
      const smoothFactor = 0.2;
      window.jogSmoothDisplayVelocity += (targetVelocity - window.jogSmoothDisplayVelocity) * smoothFactor;
      
      const velocityValue = window.jogSmoothDisplayVelocity;
      
      // Update multiplier text if we have values
      if (Math.abs(inputValue) > 1 && Math.abs(velocityValue) > 1) {
        const multiplier = Math.abs(velocityValue) / Math.max(Math.abs(inputValue), 1);
        document.getElementById('jogEffectiveness').textContent = multiplier.toFixed(1) + 'x';
      } else if (Math.abs(velocityValue) < 1) {
        document.getElementById('jogEffectiveness').textContent = '‚Äî';
      }
      
      // Helper to draw a bar
      const drawBar = (x, value, color, label) => {
        const maxValue = 100;
        const clampedValue = Math.max(-maxValue, Math.min(maxValue, value));
        const barHeight = (Math.abs(clampedValue) / maxValue) * (centerY - padding - 10);
        const barY = clampedValue >= 0 ? centerY - barHeight : centerY;
        
        ctx.fillStyle = color;
        ctx.fillRect(x - barWidth/2, barY, barWidth, Math.abs(barHeight));
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.strokeRect(x - barWidth/2, barY, barWidth, Math.abs(barHeight));
        
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(label, x, height - padding + 20);
        
        ctx.fillStyle = color;
        ctx.font = 'bold 14px sans-serif';
        const valueY = clampedValue >= 0 ? barY - 5 : barY + Math.abs(barHeight) + 15;
        ctx.fillText(Math.round(value).toString(), x, valueY);
      };
      
      const inputX = width / 2 - spacing / 2;
      drawBar(inputX, inputValue, '#faad14', 'Input');
      
      const velocityX = width / 2 + spacing / 2;
      drawBar(velocityX, velocityValue, '#667eea', 'Velocity');
      
      if (Math.abs(inputValue) > 1 || Math.abs(velocityValue) > 1) {
        const arrowY = centerY + (centerY - padding) / 2 + 20;
        ctx.strokeStyle = '#52c41a';
        ctx.fillStyle = '#52c41a';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.moveTo(inputX + barWidth/2 + 5, arrowY);
        ctx.lineTo(velocityX - barWidth/2 - 10, arrowY);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(velocityX - barWidth/2 - 10, arrowY);
        ctx.lineTo(velocityX - barWidth/2 - 18, arrowY - 4);
        ctx.lineTo(velocityX - barWidth/2 - 18, arrowY + 4);
        ctx.closePath();
        ctx.fill();
      }
      
      if (Math.abs(window.jogSmoothDisplayVelocity - targetVelocity) > 0.5 || timeSinceInput < jogInputDisplayData.holdDuration) {
        requestAnimationFrame(drawJogCurve);
      }
    }
    
    // Draw simple velocity vs input bars for SCROLL wheel
    function drawScrollCurve() {
      const canvas = document.getElementById('scrollCurveCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 40;
      const centerY = height / 2;
      const barWidth = 50;
      const spacing = 100;
      const now = Date.now();
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw center line
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, centerY);
      ctx.lineTo(width - padding, centerY);
      ctx.stroke();
      
      // Draw scale marks
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 1;
      ctx.font = '10px sans-serif';
      ctx.fillStyle = '#999';
      for (let i = -100; i <= 100; i += 50) {
        if (i === 0) continue;
        const y = centerY - (i / 100) * (centerY - padding);
        ctx.beginPath();
        ctx.moveTo(padding - 5, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
        ctx.fillText(i > 0 ? `+${i}` : i.toString(), 5, y + 3);
      }
      
      // Check if we should still show the input or fade it
      const timeSinceInput = now - scrollInputDisplayData.lastInputTime;
      let inputValue = 0;
      
      if (timeSinceInput < scrollInputDisplayData.holdDuration) {
        inputValue = scrollInputDisplayData.value;
      } else {
        inputValue = 0;
      }
      
      // Get velocity with smooth interpolation
      if (!window.scrollSmoothDisplayVelocity) window.scrollSmoothDisplayVelocity = 0;
      const targetVelocity = window.scrollCurrentDisplayVelocity || 0;
      
      const smoothFactor = 0.2;
      window.scrollSmoothDisplayVelocity += (targetVelocity - window.scrollSmoothDisplayVelocity) * smoothFactor;
      
      const velocityValue = window.scrollSmoothDisplayVelocity;
      
      // Update multiplier text if we have values
      if (Math.abs(inputValue) > 1 && Math.abs(velocityValue) > 1) {
        const multiplier = Math.abs(velocityValue) / Math.max(Math.abs(inputValue), 1);
        document.getElementById('scrollEffectiveness').textContent = multiplier.toFixed(1) + 'x';
      } else if (Math.abs(velocityValue) < 1) {
        document.getElementById('scrollEffectiveness').textContent = '‚Äî';
      }
      
      // Helper to draw a bar
      const drawBar = (x, value, color, label) => {
        const maxValue = 100;
        const clampedValue = Math.max(-maxValue, Math.min(maxValue, value));
        const barHeight = (Math.abs(clampedValue) / maxValue) * (centerY - padding - 10);
        const barY = clampedValue >= 0 ? centerY - barHeight : centerY;
        
        ctx.fillStyle = color;
        ctx.fillRect(x - barWidth/2, barY, barWidth, Math.abs(barHeight));
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.strokeRect(x - barWidth/2, barY, barWidth, Math.abs(barHeight));
        
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(label, x, height - padding + 20);
        
        ctx.fillStyle = color;
        ctx.font = 'bold 14px sans-serif';
        const valueY = clampedValue >= 0 ? barY - 5 : barY + Math.abs(barHeight) + 15;
        ctx.fillText(Math.round(value).toString(), x, valueY);
      };
      
      const inputX = width / 2 - spacing / 2;
      drawBar(inputX, inputValue, '#faad14', 'Input');
      
      const velocityX = width / 2 + spacing / 2;
      drawBar(velocityX, velocityValue, '#667eea', 'Velocity');
      
      if (Math.abs(inputValue) > 1 || Math.abs(velocityValue) > 1) {
        const arrowY = centerY + (centerY - padding) / 2 + 20;
        ctx.strokeStyle = '#52c41a';
        ctx.fillStyle = '#52c41a';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.moveTo(inputX + barWidth/2 + 5, arrowY);
        ctx.lineTo(velocityX - barWidth/2 - 10, arrowY);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(velocityX - barWidth/2 - 10, arrowY);
        ctx.lineTo(velocityX - barWidth/2 - 18, arrowY - 4);
        ctx.lineTo(velocityX - barWidth/2 - 18, arrowY + 4);
        ctx.closePath();
        ctx.fill();
      }
      
      if (Math.abs(window.scrollSmoothDisplayVelocity - targetVelocity) > 0.5 || timeSinceInput < scrollInputDisplayData.holdDuration) {
        requestAnimationFrame(drawScrollCurve);
      }
    }
    
    // Draw simple velocity vs input bars (legacy function - redirects to jog)
    function drawAccelerationCurve() {
      drawJogCurve();
    }
    
    // Update jog curve visualization with current values
    function updateJogCurveVisualization(inputSpeed, velocity) {
      // Store input value with timestamp for display hold
      jogInputDisplayData.value = inputSpeed;
      jogInputDisplayData.lastInputTime = Date.now();
      
      // Store velocity for smooth rendering
      window.jogCurrentDisplayVelocity = velocity;
      
      // Update text displays (show absolute values)
      document.getElementById('jogCurrentInput').textContent = Math.round(Math.abs(inputSpeed));
      document.getElementById('jogCurrentVelocity').textContent = Math.round(Math.abs(velocity));
      
      // Calculate and display multiplier
      if (Math.abs(inputSpeed) < 1 && Math.abs(velocity) < 1) {
        document.getElementById('jogEffectiveness').textContent = '‚Äî';
      } else {
        const multiplier = Math.abs(velocity) / Math.max(Math.abs(inputSpeed), 1);
        document.getElementById('jogEffectiveness').textContent = multiplier.toFixed(1) + 'x';
      }
      
      // Trigger smooth animation
      drawJogCurve();
    }
    
    // Update scroll curve visualization with current values
    function updateScrollCurveVisualization(inputSpeed, velocity) {
      // Store input value with timestamp for display hold
      scrollInputDisplayData.value = inputSpeed;
      scrollInputDisplayData.lastInputTime = Date.now();
      
      // Store velocity for smooth rendering
      window.scrollCurrentDisplayVelocity = velocity;
      
      // Update text displays (show absolute values)
      document.getElementById('scrollCurrentInput').textContent = Math.round(Math.abs(inputSpeed));
      document.getElementById('scrollCurrentVelocity').textContent = Math.round(Math.abs(velocity));
      
      // Calculate and display multiplier
      if (Math.abs(inputSpeed) < 1 && Math.abs(velocity) < 1) {
        document.getElementById('scrollEffectiveness').textContent = '‚Äî';
      } else {
        const multiplier = Math.abs(velocity) / Math.max(Math.abs(inputSpeed), 1);
        document.getElementById('scrollEffectiveness').textContent = multiplier.toFixed(1) + 'x';
      }
      
      // Trigger smooth animation
      drawScrollCurve();
    }
    
    // Legacy function - redirects to jog
    function updateCurveVisualization(inputSpeed, velocity) {
      updateJogCurveVisualization(inputSpeed, velocity);
    }
    
    // Initialize curve visualization on load
    window.addEventListener('load', () => {
      console.log('üöÄ Page loaded, initializing...');
      
      drawJogCurve();
      drawScrollCurve();
      drawJogTimeline();
      drawScrollTimeline();
      // Start timeline update loops
      setInterval(updateJogTimeline, 50); // Update 20 times per second
      setInterval(updateScrollTimeline, 50);
      
      // Fetch initial config from server
      console.log('üì° Fetching config from /api/config...');
      fetch('/api/config')
        .then(res => {
          console.log('üì° Fetch response status:', res.status);
          return res.json();
        })
        .then(data => {
          console.log('üìù Initial config loaded from API:', data);
          config = data;
          renderMappings();
          loadPhysicsSettings();
        })
        .catch(err => {
          console.error('‚ùå Failed to load config:', err);
          // Load defaults if fetch fails
          config = { buttons: {}, scrollWheels: {}, friction: 50, sensitivity: 50 };
          loadPhysicsSettings();
        });
    });
    
    // Update global friction
    function updateFriction(value) {
      const friction = Math.round(parseFloat(value));
      globalFriction = friction;
      if (config) config.friction = friction;
      
      // Show actual value (5-100 range)
      document.getElementById('frictionValue').textContent = friction;
      
      console.log(`üéõÔ∏è  Friction updated to ${friction}`);
      
      // Send to server for physics engine (auto-saves to config.json)
      fetch('/api/physics/friction', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ value: friction })
      }).catch(err => console.error('Failed to update friction:', err));
    }
    
    // Update jog wheel visualization
    function updateJogWheel(event) {
      // Record input time
      jogWheelData.lastInputTime = Date.now();
      
      // Calculate target velocity based on input
      const inputSpeed = event.amount;
      const direction = event.direction === 'up' ? 1 : -1;
      const signedInput = inputSpeed * direction;
      const targetVelocity = inputSpeed * TARGET_MULTIPLIER * direction;
      
      // Record input event for timeline
      recordJogInputEvent(targetVelocity, inputSpeed * TARGET_MULTIPLIER);
      
      // Calculate acceleration with friction (use default 50 if not loaded yet)
      // Lower friction (5-49) = faster acceleration and slower deceleration (more momentum)
      // Higher friction (51-100) = slower acceleration and faster deceleration (more resistance)
      const friction = globalFriction !== null ? globalFriction : 50;
      const frictionFactor = Math.max(0.1, friction / 50); // Clamp minimum to 0.1 to prevent division issues
      const accelerationRate = Math.min(0.5, 0.2 / frictionFactor); // Cap max acceleration rate
      
      // Apply acceleration toward target
      const velocityDiff = targetVelocity - jogWheelData.velocity;
      jogWheelData.velocity += velocityDiff * accelerationRate;
      
      // Update stats
      jogWheelData.totalScrolls++;
      jogWheelData.lastDirection = event.direction;
      
      // Track highest speed in current series
      if (event.amount > jogWheelData.currentSeriesHighest) {
        jogWheelData.currentSeriesHighest = event.amount;
        jogWheelData.highestSpeed = event.amount;
        document.getElementById('jogHighestSpeed').textContent = event.amount;
      }
      
      // Clear existing debounce timer
      if (jogWheelData.debounceTimer) {
        clearTimeout(jogWheelData.debounceTimer);
      }
      
      // Set new debounce timer - reset series after 250ms of no movement
      jogWheelData.debounceTimer = setTimeout(() => {
        jogWheelData.currentSeriesHighest = 0;
      }, 250);
      
      // Update stats display
      document.getElementById('jogScrolls').textContent = jogWheelData.totalScrolls;
      document.getElementById('jogDirection').textContent = event.direction === 'up' ? '‚Üë' : '‚Üì';
      document.getElementById('jogDirection').style.color = event.direction === 'up' ? '#52c41a' : '#ff4d4f';
      
      // Update speed
      document.getElementById('jogSpeed').textContent = event.amount;
      const speedColor = event.amount > 50 ? '#ff4d4f' : event.amount > 20 ? '#faad14' : '#52c41a';
      document.getElementById('jogSpeed').style.color = speedColor;
      
      // Update curve visualization with signed input
      updateJogCurveVisualization(signedInput * TARGET_MULTIPLIER, jogWheelData.velocity);
      
      // Start physics animation if not already running
      if (!jogWheelData.animationFrame) {
        jogWheelData.animationFrame = requestAnimationFrame(animateJogWheel);
      }
    }
    
    function resetJogPosition() {
      if (jogWheelData.debounceTimer) {
        clearTimeout(jogWheelData.debounceTimer);
      }
      if (jogWheelData.animationFrame) {
        cancelAnimationFrame(jogWheelData.animationFrame);
      }
      jogWheelData = {
        position: 0,
        totalScrolls: 0,
        lastDirection: null,
        highestSpeed: 0,
        currentSeriesHighest: 0,
        debounceTimer: null,
        velocity: 0,
        lastInputTime: 0,
        animationFrame: null
      };
      document.getElementById('jogPosition').textContent = '0';
      document.getElementById('jogProgress').style.strokeDashoffset = '502.65';
      document.getElementById('jogScrolls').textContent = '0';
      document.getElementById('jogDirection').textContent = '‚Äî';
      document.getElementById('jogDirection').style.color = '#333';
      document.getElementById('jogSpeed').textContent = '‚Äî';
      document.getElementById('jogSpeed').style.color = '#333';
      document.getElementById('jogHighestSpeed').textContent = '0';
      showToast('üîÑ Jog wheel position reset');
    }
    
    function resetScrollPosition() {
      if (scrollWheelData.debounceTimer) {
        clearTimeout(scrollWheelData.debounceTimer);
      }
      if (scrollWheelData.animationFrame) {
        cancelAnimationFrame(scrollWheelData.animationFrame);
      }
      scrollWheelData = {
        position: 0,
        totalScrolls: 0,
        lastDirection: null,
        highestSpeed: 0,
        currentSeriesHighest: 0,
        debounceTimer: null,
        velocity: 0,
        lastInputTime: 0,
        animationFrame: null
      };
      document.getElementById('scrollPosition').textContent = '0';
      document.getElementById('scrollProgress').style.strokeDashoffset = '502.65';
      document.getElementById('scrollScrolls').textContent = '0';
      document.getElementById('scrollDirection').textContent = '‚Äî';
      document.getElementById('scrollDirection').style.color = '#333';
      document.getElementById('scrollSpeed').textContent = '‚Äî';
      document.getElementById('scrollSpeed').style.color = '#333';
      document.getElementById('scrollHighestSpeed').textContent = '0';
      showToast('üîÑ Scroll wheel position reset');
    }
    
    // Update global sensitivity
    function updateSensitivity(value) {
      const sensitivity = Math.round(parseFloat(value));
      globalSensitivity = sensitivity;
      if (config) config.sensitivity = sensitivity;
      
      document.getElementById('sensitivityValue').textContent = sensitivity;
      
      console.log(`üéõÔ∏è  Sensitivity updated to ${sensitivity}`);
      
      // Send to server for physics engine (auto-saves to config.json)
      fetch('/api/physics/sensitivity', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ value: sensitivity })
      }).catch(err => console.error('Failed to update sensitivity:', err));
    }
    
    // Update scroll wheel visualization
    function updateScrollWheel(event) {
      // Record input time
      scrollWheelData.lastInputTime = Date.now();
      
      // Calculate target velocity based on input
      const inputSpeed = event.amount;
      const direction = event.direction === 'up' ? 1 : -1;
      const signedInput = inputSpeed * direction;
      const targetVelocity = inputSpeed * TARGET_MULTIPLIER * direction;
      
      // Record input event for timeline
      recordScrollInputEvent(targetVelocity, inputSpeed * TARGET_MULTIPLIER);
      
      // Calculate acceleration with friction (use default 50 if not loaded yet)
      // Lower friction (5-49) = faster acceleration and slower deceleration (more momentum)
      // Higher friction (51-100) = slower acceleration and faster deceleration (more resistance)
      const friction = globalFriction !== null ? globalFriction : 50;
      const frictionFactor = Math.max(0.1, friction / 50); // Clamp minimum to 0.1 to prevent division issues
      const accelerationRate = Math.min(0.5, 0.2 / frictionFactor); // Cap max acceleration rate
      
      // Apply acceleration toward target
      const velocityDiff = targetVelocity - scrollWheelData.velocity;
      scrollWheelData.velocity += velocityDiff * accelerationRate;
      
      // Update stats
      scrollWheelData.totalScrolls++;
      scrollWheelData.lastDirection = event.direction;
      
      // Track highest speed in current series
      if (event.amount > scrollWheelData.currentSeriesHighest) {
        scrollWheelData.currentSeriesHighest = event.amount;
        scrollWheelData.highestSpeed = event.amount;
        document.getElementById('scrollHighestSpeed').textContent = event.amount;
      }
      
      // Clear existing debounce timer
      if (scrollWheelData.debounceTimer) {
        clearTimeout(scrollWheelData.debounceTimer);
      }
      
      // Set new debounce timer - reset series after 250ms of no movement
      scrollWheelData.debounceTimer = setTimeout(() => {
        scrollWheelData.currentSeriesHighest = 0;
      }, 250);
      
      // Update stats display
      document.getElementById('scrollScrolls').textContent = scrollWheelData.totalScrolls;
      document.getElementById('scrollDirection').textContent = event.direction === 'up' ? '‚Üë' : '‚Üì';
      document.getElementById('scrollDirection').style.color = event.direction === 'up' ? '#52c41a' : '#ff4d4f';
      
      // Update speed
      document.getElementById('scrollSpeed').textContent = event.amount;
      const speedColor = event.amount > 50 ? '#ff4d4f' : event.amount > 20 ? '#faad14' : '#52c41a';
      document.getElementById('scrollSpeed').style.color = speedColor;
      
      // Update curve visualization with signed input
      updateScrollCurveVisualization(signedInput * TARGET_MULTIPLIER, scrollWheelData.velocity);
      
      // Start physics animation if not already running
      if (!scrollWheelData.animationFrame) {
        scrollWheelData.animationFrame = requestAnimationFrame(animateScrollWheel);
      }
    }
    
    
    // Physics animation loop for jog wheel
    function animateJogWheel() {
      const now = Date.now();
      const timeSinceInput = now - jogWheelData.lastInputTime;
      
      // Stop if velocity is too small
      if (Math.abs(jogWheelData.velocity) < VELOCITY_THRESHOLD) {
        jogWheelData.velocity = 0;
        jogWheelData.animationFrame = null;
        // Update only velocity, not input
        window.jogCurrentDisplayVelocity = 0;
        drawJogCurve();
        return;
      }
      
      // Apply friction if no recent input
      if (timeSinceInput > 50) {
        // Apply friction-based exponential decay (use default 50 if not loaded yet)
        // Lower friction (5-49) = slower decay (more momentum/coasting)
        // Higher friction (51-100) = faster decay (quicker stop)
        const friction = globalFriction !== null ? globalFriction : 50;
        const frictionFactor = Math.max(0.1, friction / 50); // Clamp minimum to prevent issues
        const baseDecayRate = 0.92; // Base decay at friction = 50
        // Scale decay rate: lower friction = closer to 1 (slower decay), higher friction = further from 1 (faster decay)
        const decayRate = Math.max(0.8, Math.min(0.99, 1 - ((1 - baseDecayRate) * frictionFactor))); // Clamp between 0.8 and 0.99
        jogWheelData.velocity *= decayRate;
        
        // Check again if velocity dropped below threshold after friction
        if (Math.abs(jogWheelData.velocity) < VELOCITY_THRESHOLD) {
          jogWheelData.velocity = 0;
          jogWheelData.animationFrame = null;
          window.jogCurrentDisplayVelocity = 0;
          drawJogCurve();
          return;
        }
      }
      
      // Update position based on velocity with sensitivity scaling (use default 50 if not loaded yet)
      const sensitivity = globalSensitivity !== null ? globalSensitivity : 50;
      const scaledVelocity = jogWheelData.velocity * (sensitivity / 50); // 50 is baseline (1x)
      jogWheelData.position += scaledVelocity;
      
      // Update UI
      document.getElementById('jogPosition').textContent = Math.round(jogWheelData.position);
      
      // Update progress circle
      const normalizedPos = ((jogWheelData.position % 360) + 360) % 360;
      const circumference = 502.65;
      const offset = circumference - (normalizedPos / 360) * circumference;
      document.getElementById('jogProgress').style.strokeDashoffset = offset;
      
      // Update only velocity display, not input
      window.jogCurrentDisplayVelocity = jogWheelData.velocity;
      document.getElementById('jogCurrentVelocity').textContent = Math.round(Math.abs(jogWheelData.velocity));
      drawJogCurve();
      
      // Continue animation
      jogWheelData.animationFrame = requestAnimationFrame(animateJogWheel);
    }
    
    // Physics animation loop for scroll wheel
    function animateScrollWheel() {
      const now = Date.now();
      const timeSinceInput = now - scrollWheelData.lastInputTime;
      
      // Stop if velocity is too small
      if (Math.abs(scrollWheelData.velocity) < VELOCITY_THRESHOLD) {
        scrollWheelData.velocity = 0;
        scrollWheelData.animationFrame = null;
        return;
      }
      
      // Apply friction if no recent input
      if (timeSinceInput > 50) {
        // Apply friction-based exponential decay (use default 50 if not loaded yet)
        // Lower friction (5-49) = slower decay (more momentum/coasting)
        // Higher friction (51-100) = faster decay (quicker stop)
        const friction = globalFriction !== null ? globalFriction : 50;
        const frictionFactor = Math.max(0.1, friction / 50); // Clamp minimum to prevent issues
        const baseDecayRate = 0.92; // Base decay at friction = 50
        // Scale decay rate: lower friction = closer to 1 (slower decay), higher friction = further from 1 (faster decay)
        const decayRate = Math.max(0.8, Math.min(0.99, 1 - ((1 - baseDecayRate) * frictionFactor))); // Clamp between 0.8 and 0.99
        scrollWheelData.velocity *= decayRate;
        
        // Check again if velocity dropped below threshold after friction
        if (Math.abs(scrollWheelData.velocity) < VELOCITY_THRESHOLD) {
          scrollWheelData.velocity = 0;
          scrollWheelData.animationFrame = null;
          return;
        }
      }
      
      // Update position based on velocity with sensitivity scaling (use default 50 if not loaded yet)
      const sensitivity = globalSensitivity !== null ? globalSensitivity : 50;
      const scaledVelocity = scrollWheelData.velocity * (sensitivity / 50); // 50 is baseline (1x)
      scrollWheelData.position += scaledVelocity;
      
      // Update UI
      document.getElementById('scrollPosition').textContent = Math.round(scrollWheelData.position);
      
      // Update only velocity display, not input
      window.scrollCurrentDisplayVelocity = scrollWheelData.velocity;
      document.getElementById('scrollCurrentVelocity').textContent = Math.round(Math.abs(scrollWheelData.velocity));
      drawScrollCurve();
      
      // Update progress circle
      const normalizedPos = ((scrollWheelData.position % 360) + 360) % 360;
      const circumference = 502.65;
      const offset = circumference - (normalizedPos / 360) * circumference;
      document.getElementById('scrollProgress').style.strokeDashoffset = offset;
      
      // Continue animation
      scrollWheelData.animationFrame = requestAnimationFrame(animateScrollWheel);
    }
    
    // Update log
    function updateLog(report) {
      const logDiv = document.getElementById('log');
      
      report.events.forEach((event, idx) => {
        const time = new Date(report.timestamp).toLocaleTimeString();
        const entryId = `log-${Date.now()}-${idx}`;
        let message = '';
        let className = event.type;
        let actions = '';
        
        if (event.type === 'button') {
          const isKnown = !event.name.startsWith('Unknown Button');
          if (isKnown) className += ' known';
          const checkmark = isKnown ? ' ‚úì' : '';
          
          // Show bit value if available (helps identify multiple buttons in same byte)
          const bitInfo = event.bitValue ? ` (bit: ${event.bitValue})` : '';
          message = `<span class="event-badge button">BUTTON</span> ${event.name}${checkmark} ${event.action.toUpperCase()}${bitInfo}`;
          
          // Only show "Add Mapping" for unknown buttons
          if (event.name.startsWith('Unknown Button')) {
            const byteInfo = event.bitValue ? `[byte ${event.byte}, value ${event.bitValue}]` : `[${event.byte}]`;
            const bitValueParam = event.bitValue || 'null';
            actions = `
              <div class="log-actions">
                <input type="text" id="${entryId}-name" placeholder="Enter button name..." 
                       onkeypress="if(event.key === 'Enter') quickAddButton(${event.byte}, '${entryId}-name', ${bitValueParam})" />
                <button onclick="quickAddButton(${event.byte}, '${entryId}-name', ${bitValueParam})">
                  ‚ûï Map Button ${byteInfo}
                </button>
              </div>
            `;
          } else {
            // Show confirmation for mapped buttons
            const mappingInfo = event.bitValue ? `byte ${event.byte}, bit ${event.bitValue}` : `byte ${event.byte}`;
            actions = `
              <div style="color: #52c41a; font-size: 12px; margin-top: 4px;">
                Mapped control (${mappingInfo})
              </div>
            `;
          }
        } else if (event.type === 'scroll') {
          const isKnown = !event.name.startsWith('Unknown Scroll');
          if (isKnown) className += ' known';
          const checkmark = isKnown ? ' ‚úì' : '';
          
          // Show raw velocity value if available
          const velocityInfo = event.rawValue ? ` [velocity: ${event.rawValue}]` : '';
          message = `<span class="event-badge scroll">SCROLL</span> ${event.name}${checkmark} ${event.direction.toUpperCase()} by ${event.amount}${velocityInfo} (pos: ${event.position})`;
          
          // Update jog wheel visualization if this is the jog wheel
          if (event.name === 'Jog' || event.name.includes('Jog')) {
            updateJogWheel(event);
          }
          
          // Update scroll wheel visualization if this is the scroll wheel
          if (event.name === 'Scroll' || event.name.includes('Scroll')) {
            updateScrollWheel(event);
          }
          
          // Only show "Add Mapping" for unknown scrolls
          if (event.name.startsWith('Unknown Scroll')) {
            actions = `
              <div class="log-actions">
                <input type="text" id="${entryId}-name" placeholder="Enter wheel name..." 
                       onkeypress="if(event.key === 'Enter') quickAddScroll(${event.byte}, '${entryId}-name')" />
                <button onclick="quickAddScroll(${event.byte}, '${entryId}-name')">
                  ‚ûï Map Scroll Wheel [${event.byte}]
                </button>
              </div>
            `;
          } else {
            // Show confirmation for mapped scrolls
            actions = `
              <div style="color: #52c41a; font-size: 12px; margin-top: 4px;">
                Mapped control (byte ${event.byte})
              </div>
            `;
          }
        } else if (event.type === 'value') {
          message = `<span class="event-badge value">VALUE</span> ${event.name}: ${event.prev} ‚Üí ${event.curr}`;
        }
        
        logEntries.unshift(`
          <div class="log-entry ${className}">
            <span class="timestamp">${time}</span> ${message}
            ${actions}
          </div>
        `);
      });
      
      // Keep only last MAX_LOG_ENTRIES
      logEntries = logEntries.slice(0, MAX_LOG_ENTRIES);
      logDiv.innerHTML = logEntries.join('');
    }
    
    // Toast notification
    function showToast(message, type = 'success') {
      const toast = document.createElement('div');
      toast.className = 'toast';
      if (type === 'warning') toast.classList.add('warning');
      if (type === 'error') toast.classList.add('error');
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.style.animation = 'slideIn 0.3s ease-out reverse';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }
    
    // Quick add functions
    async function quickAddButton(byte, inputId, bitValue = null) {
      const input = document.getElementById(inputId);
      const name = input.value.trim();
      
      if (!name) {
        showToast('‚ö†Ô∏è Please enter a button name', 'warning');
        input.focus();
        return;
      }
      
      // Use byte:bitValue as key if bitValue is provided (for multiple buttons on same byte)
      const key = bitValue ? `${byte}:${bitValue}` : byte;
      
      // Update local config
      config.buttons[key] = name;
      renderMappings();
      
      // Auto-save to server so future events use this mapping
      await fetch('/api/config', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
      });
      
      // Clear the input
      input.value = '';
      input.style.border = '2px solid #52c41a';
      setTimeout(() => {
        input.style.border = '1px solid #555';
      }, 1000);
      
      // Show success message
      const keyInfo = bitValue ? `[byte ${byte}, bit ${bitValue}]` : `[${byte}]`;
      showToast(`‚úÖ Button ${keyInfo} ‚Üí "${name}" (saved & active!)`);
    }
    
    async function quickAddScroll(byte, inputId) {
      const input = document.getElementById(inputId);
      const name = input.value.trim();
      
      if (!name) {
        showToast('‚ö†Ô∏è Please enter a wheel name', 'warning');
        input.focus();
        return;
      }
      
      // Update local config
      config.scrollWheels[byte] = name;
      renderMappings();
      
      // Auto-save to server so future events use this mapping
      await fetch('/api/config', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
      });
      
      // Clear the input
      input.value = '';
      input.style.border = '2px solid #52c41a';
      setTimeout(() => {
        input.style.border = '1px solid #555';
      }, 1000);
      
      // Show success message
      showToast(`‚úÖ Scroll [${byte}] ‚Üí "${name}" (saved & active!)`);
    }
    
    function clearLog() {
      logEntries = [];
      document.getElementById('log').innerHTML = '';
      showToast('üóëÔ∏è Log cleared');
    }
  </script>
</body>
</html>
